<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cjwind&#39;s note</title>
  
  <subtitle>如果只知道堅守昨天的成果，&lt;br&gt;明天又會變成什麼樣呢？</subtitle>
  <link href="http://www.cjwind.idv.tw/atom.xml" rel="self"/>
  
  <link href="http://www.cjwind.idv.tw/"/>
  <updated>2020-08-29T07:35:30.753Z</updated>
  <id>http://www.cjwind.idv.tw/</id>
  
  <author>
    <name>cjwind</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ch10 I Can&#39;t Run This Method in a Test Harness</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch10-I-Can-t-Run-This-Method-in-a-Test-Harness/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch10-I-Can-t-Run-This-Method-in-a-Test-Harness/</id>
    <published>2020-08-29T07:35:09.000Z</published>
    <updated>2020-08-29T07:35:30.753Z</updated>
    
    <content type="html"><![CDATA[<p>要為一段 code 寫測試，首先要在測試中建立它所屬的 class 的 instance，接著為要修改的 method 寫測試。這章要解決的是「難以在測試中執行要測試的 method」的情境。為一個 method 寫測試可能會遇到的問題：</p><ul><li>無法在測試中 access 那個 method，例如它可能是 private 的或是有其他存取限制。</li><li>很難建立所需參數，導致很難 call method，例如參數是一包 XML。</li><li>要測試的 method 可能產生糟糕的 side effect，例如修改 DB、發射飛彈等等，所以無法在測試中執行它。</li><li>需要透過該 method 使用的 object 進行 sense，才能知道這個 method 做了什麼事。</li></ul><h1 id="The-Case-of-the-Hidden-Method"><a href="#The-Case-of-the-Hidden-Method" class="headerlink" title="The Case of the Hidden Method"></a>The Case of the Hidden Method</h1><p>假設我們要修改的是一個 private method，想要測試它，該怎麼辦呢？</p><p>首先，能透過 public method 來測試它嗎？如果可以，就這麼幹吧～用 public method 去測試，就是按照程式中 private method 如何被使用的方式去測試它。如果有天要把 private method 改成 public，把它變成 public 的人應該寫一系列的測試說明這個 method 的用途以及 caller 該如何使用它。</p><p>這邊有提到一點 method 設計實作上的小概念：</p><blockquote><p>雖然 general 的 method 對 caller 來說蠻有用的，但每個 method 的功能應該剛好可以滿足 caller 並且易於理解與修改。</p></blockquote><p>有時候呢，我們就是想直接為 private method 寫測試（任性），可能是因為我們想用測試來知道如何使用 private method，或者用 public method 來測試它實在太難太痛苦啦～</p><p>例如一個擁有商業邏輯並且會 call third-party API 的 class 做的事情是：call API 取得一包 XML 資料，parse XML 得到商業邏輯需要的資料，再做商業邏輯上的計算或操作。我們想知道 parse XML 的 private method 是否正確，但它埋在整個流程裡，而用 public method 做整個的 call API、parsing、商業邏輯的測試難以只測試到 parse XML 的部份。</p><p>所以，想為 private method 寫測試時該怎麼辦呢？</p><blockquote><p>如果需要測試一個 private method，就該把它設成 public。</p></blockquote><p>看到書上這句話我蠻驚恐的，想著：「等等等，不是吧？就這樣直接把 private method 變成 public 好嗎？這不會在 class 上開出看起來突兀或者不知如何使用的 method 嗎？」</p><blockquote><p>如果不方便將其設為 public，大多數情況下意味著我們的 class 做太多事了，應該進行調整。</p></blockquote><p>喔～原來是這樣～這倒是真的～像上面那個例子，一個 class 既 call third-party API 又 parse XML 又做商業邏輯，太多事情了。</p><p>如果我們想測試一個 private method，首先看它是不是個適合在這個 class 當作 public 的 method？如果是，直接改成 public。否則看看是不是這個 class 做太多事了，有些事可以交由另一個 class 處理。例如我們把 parse XML 有關的 method 放到另一個 parser class，這些 method 到了新 class 會變成 public，原本的 class 就能 new 一個 parser 出來做事。</p><blockquote><p>好的設計應當是可測試的，不具可測試性的設計是糟糕的。</p></blockquote><p>如果我們遇到上面這樣的狀況，想拆解 class、將職責分開，卻沒有多少現成測試呢？假設我們想拆解這個包山包海的 class，但它本身卻沒有什麼測試，而 refactor 應當要有測試保護，雞生蛋蛋生雞的問題出現啦～</p><p>又或許，我們正在開發週期的後期，軟體已經接近 deploy，我們沒有多少時間去做拆解的 refactor，而且沒有測試又讓 refactor 的風險大幅提昇。儘管 refactor 可以改善程式結構、有好處，但需要考慮目前處於開發週期的哪個階段、時間多寡與風險高低，才能決定要不要 refactor 以及 refactor 到什麼程度。</p><p>時間不夠或風險太高的時，我們無法拆解 class。退而求其次，至少幫我們要修改的 private method 加上測試，讓這個 class 開始有測試保護也是好的。</p><p>想為 private method 加上測試，表示要能在測試中直接 call 到這個 method，要怎麼做呢？</p><p>又用到 Extract and Override 了～<em>這招也太萬用…</em></p><p>假設我們有個與機票搜尋、訂購有關的 class：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">$searchParams</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call third party api and get response as xml</span></span><br><span class="line">    $searchResults = <span class="keyword">$this</span>-&gt;parseSearchResponse($xml);</span><br><span class="line">    <span class="comment">// other impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params">$xml</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">booking</span>(<span class="params">$bookingParams</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>search()</code> 裡先用 http client 向 third party API 送 request 並收 response，response 是一包 XML，我們想 parse 出其中需要的資料而 call <code>parseSearchResponse()</code>。因為 XML 相當複雜，我們希望能單獨確認 parsing 結果是否正確。</p><p>這個 class 除了 search、booking、parse 各種 XML 之外還會做許多事情，它的職責太多了，如果我們現在沒有時間去拆解它，卻想測試 <code>parseSearchResponse()</code> 的結果該怎麼做？</p><p>首先將 <code>parseSearchResponse()</code> 從 <code>private</code> 變成 <code>protected</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">$searchParams</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call third party api and get response as xml</span></span><br><span class="line">    $searchResults = <span class="keyword">$this</span>-&gt;parseSearchResponse($xml);</span><br><span class="line">    <span class="comment">// other impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 變成 protected</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params">$xml</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著在測試中繼承它：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlightForTest</span> <span class="keyword">extends</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params">$xml</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parent</span>::parseSearchResponse($xml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就能在測試 call 到 <code>parseSearchResponse()</code> 進行測試了：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlightTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testParseSearchResponse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $target = <span class="keyword">new</span> FlightForTest();</span><br><span class="line">    $xml = <span class="string">&#x27;blabla&#x27;</span>;</span><br><span class="line">    $ret = $target-&gt;parseSearchResponse($xml);</span><br><span class="line">    <span class="comment">// assertions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這麼做雖然沒有立即改善 <code>Flight</code> 做太多事的問題，但至少幫修改的地方加上測試，確保目前的修改是正確的。並且為將來拆解 class 的 refactor 鋪路――因為加了些測試而減少之後 refactor 所需的 effort 跟時間，使之後 refactor 成為可能。</p><h1 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h1><ul><li><a href="https://dotblogs.com.tw/hatelove/2012/07/19/why-you-should-not-write-unit-test-with-private-and-protected-method">[測試]單元測試：是否針對非 public method 進行測試？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要為一段 code 寫測試，首先要在測試中建立它所屬的 class 的 instance，接著為要修改的 method 寫測試。這章要解決的是「難以在測試中執行要測試的 method」的情境。為一個 method 寫測試可能會遇到的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無法在測</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Refactor" scheme="http://www.cjwind.idv.tw/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>安裝 mariadb 並設定 root password</title>
    <link href="http://www.cjwind.idv.tw/Install-mariadb-and-setup-root-password/"/>
    <id>http://www.cjwind.idv.tw/Install-mariadb-and-setup-root-password/</id>
    <published>2020-08-16T09:57:52.000Z</published>
    <updated>2020-08-16T10:00:18.394Z</updated>
    
    <content type="html"><![CDATA[<p>在 Debian，先安裝：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install mariadb-server</span></span><br></pre></td></tr></table></figure><p>裝完做些跟安全有關的設定跟 root password：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mysql_secure_installation</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Debian，先安裝：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="DB" scheme="http://www.cjwind.idv.tw/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>ch5 Tools</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch5-Tools/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch5-Tools/</id>
    <published>2020-08-13T01:19:58.000Z</published>
    <updated>2020-08-14T00:58:52.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul><li>自動化重構工具<ul><li>像 JetBrains、Visual Studio 等 IDE 的 refactor 功能。</li><li>在工具夠好的情況下，可以在沒有為 code 寫測試的情況下用工具進行自動化 refactor。但有時工具可能有問題，refactor 卻會修改到程式行為，所以使用工具進行 refactor 前，如果能先寫測試還是比較好的。</li><li>要注意工具在 refactor 時會跟不會進行哪些檢查<ul><li>例如 extract method，如果將新 method 命名為已存在 method 的名字，工具會不會顯示錯誤？</li></ul></li></ul></li><li>Unit Test 工具<ul><li>xUnit framework<br>  這類型 framework 執行測試大致的作法：找到 test class 裡所有 test method（依據語言不同有不同作法，有些語言可以用 reflection），為每個 test method 產生一個單獨的 object，該 object 的任務是去執行那個 test method。利用不同 object 隔離 test case，讓 test case 不會互相影響。</li></ul></li><li>一般測試控制工具<ul><li>FIT (Framework for Integration Test）</li><li>Fitnesse</li><li>Selenium</li><li><em>……等等其他</em></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;自動化重構工具&lt;ul&gt;
&lt;li&gt;像 JetBrains、Visual Studio 等 </summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Refactor" scheme="http://www.cjwind.idv.tw/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>ch4 The Seam Model</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch4-The-Seam-Model/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch4-The-Seam-Model/</id>
    <published>2020-08-11T01:11:13.000Z</published>
    <updated>2020-08-11T01:11:32.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Seam-amp-Enabling-Point"><a href="#Seam-amp-Enabling-Point" class="headerlink" title="Seam &amp; Enabling Point"></a>Seam &amp; Enabling Point</h1><p>seam（接縫）是指程式中一些特殊的點，在這些點上你不需要修改它本身就可以變動程式行為。</p><p>例如某段程式 call 了一個 function 來計算商品價格，現在想改變計算價格的 strategy。想在不改變 call 計價 function 的情況下，改變計價結果（程式行為）。</p><p>又例如程式 call 到牽連龐大子系統的 function，我們希望在 test 中避免執行到那些複雜的 code（不然很難測或無法測），又要在 prodcution code 裡照常執行到。如果這段 code 有 seam，便能在不改動到原本 call function 的情況下，換掉該 function 的行為來避免在 test 中碰到子系統。</p><p>每個 seam 都有一個 enabling point，在這裡你可以決定使用哪種行為。</p><p>seam 是可以讓你改變程式行為的「縫隙」，enabling point 則是決定那個 seam 要是什麼行為。在 enabling point 給不同的值，可以讓 seam 有不同的行為。例如物件 seam，物件 method 的參數列表是 enabling point，因為我們可以傳入不同的物件來改變程式行為。</p><p>為一團亂的 code 測試時，最好別去修改它本身，盡可能透過 seam 去解開 dependency 來測試。</p><h1 id="Seam-Types"><a href="#Seam-Types" class="headerlink" title="Seam Types"></a>Seam Types</h1><p>seam 有很多種類型。不同的語言，可以使用的類型也不同。一個語言從程式碼轉換到 machine code 的各個階段，擁有不同種類的 seam。</p><ul><li>preprocess 時期 seam<ul><li>在 C/C++ 裡可以用 macro 直接把字換掉來達到改變行為，例如直接把有 dependency 的 function call 用 <code>#define</code> 在 <code>#ifdef TESTING</code> 時換成空的 function。</li><li>enabling point 是 <code>#define TESTING</code></li></ul></li><li>link 時期 seam：在將多個 object file link 起來時的 seam<ul><li>dynamic link：直接換掉 dynamic link 要去找的 library 或 object file。</li><li>static link：透過 build script（像 Makefile），在測試環境去 link 抽換的 object file 而非原本 production code 的 object file。</li><li>enabling point 通常在 build 或 deploy script 裡，因為這時候才決定 link 誰。</li></ul></li><li>object seam<ul><li>一般用 interface、polymorphism 來做 dependency injection，以及 extract and override。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Seam-amp-Enabling-Point&quot;&gt;&lt;a href=&quot;#Seam-amp-Enabling-Point&quot; class=&quot;headerlink&quot; title=&quot;Seam &amp;amp; Enabling Point&quot;&gt;&lt;/a&gt;Seam &amp;amp; Enab</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Refactor" scheme="http://www.cjwind.idv.tw/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>Debian 10 Desktop 中文輸入</title>
    <link href="http://www.cjwind.idv.tw/Debian-10-Desktop-Chinese/"/>
    <id>http://www.cjwind.idv.tw/Debian-10-Desktop-Chinese/</id>
    <published>2020-08-09T06:41:36.000Z</published>
    <updated>2020-08-09T07:10:54.014Z</updated>
    
    <content type="html"><![CDATA[<p>先安裝 ibus：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install ibus ibus-chewing</span><br></pre></td></tr></table></figure><p>在 <code>~/.bashrc</code>  加入：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GTK_IM_MODULE</span>=ibus</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">XMODIFIERS</span>=@im=ibus</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">QT_IM_MODULE</span>=ibus</span><br></pre></td></tr></table></figure><p>寫個 shell script：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ibus-daemon -d -x</span><br></pre></td></tr></table></figure><p>在 KDE Setting 的 Autostart 設定啟動時執行 shell script 來啟動 ibus</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先安裝 ibus：&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-&lt;span class=&quot;builtin-name</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://www.cjwind.idv.tw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git diff &amp; patch</title>
    <link href="http://www.cjwind.idv.tw/Git-diff-and-patch/"/>
    <id>http://www.cjwind.idv.tw/Git-diff-and-patch/</id>
    <published>2020-07-05T06:35:44.000Z</published>
    <updated>2020-08-09T03:17:09.268Z</updated>
    
    <content type="html"><![CDATA[<p>用 Git diff 生 patch file</p><p><code>$ git diff [file] &gt; [path_file]</code></p><p>上 patch</p><p><code>$ patch -p1 &lt; [path_file]</code></p><ul><li>加 <code>-d [dir path]</code> 可以切換 directory</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://blog.longwin.com.tw/2013/08/linux-diff-patch-learn-note-2013/">https://blog.longwin.com.tw/2013/08/linux-diff-patch-learn-note-2013/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用 Git diff 生 patch file&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git diff [file] &amp;gt; [path_file]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上 patch&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ patch -p1 &amp;lt; [path_file]&lt;/</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://www.cjwind.idv.tw/tags/Linux/"/>
    
    <category term="Git" scheme="http://www.cjwind.idv.tw/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Day 4 C 語言與畫面顯示的練習</title>
    <link href="http://www.cjwind.idv.tw/30dayos/day4/"/>
    <id>http://www.cjwind.idv.tw/30dayos/day4/</id>
    <published>2020-05-08T13:42:52.000Z</published>
    <updated>2020-08-09T03:17:09.264Z</updated>
    
    <content type="html"><![CDATA[<p>這天很多在介紹 C，尤其是 pointer，作者用組語的角度去看 C，很有趣。這邊只寫些簡單的筆記。</p><p>組語跟 C 一起使用時，只有 <code>EAX</code>、<code>ECX</code>、<code>EDX</code> 三個 register 可以使用，其他 register 只能 read 不能 write，因為它們存著 C 語言程式的相關資料。</p><p>C 語言中，普通數值跟表示 memory address 的數值被當作兩種不同的東西。</p><p>根據 C 語言規定，組語執行 <code>RET</code> 指令時， <code>EAX</code> 中的值就被看作是 function return value。</p><h2 id="調色盤設定顏色"><a href="#調色盤設定顏色" class="headerlink" title="調色盤設定顏色"></a>調色盤設定顏色</h2><p>在 8 bit 彩色模式下，顏色以 8 個 bit 表示，也就是 0~255。</p><p>每個數字表示什麼顏色，是由 developer 來決定的，不像 RGB 的 <code>#ffffff</code> 固定代表某個顏色。使用 0~255 表示顏色前，developer 要先幫這些數字指定好對應的顏色，例如 25 對應 <code>#ffffff</code> 等等。這種方式稱為「調色盤」。</p><p>設定調色盤的步驟如下：</p><ol><li>先 block interrupt</li><li>依據設定調色盤的方式，對 IO device 的某些 port 寫入資料</li><li>恢復對 interrupt 的處理</li></ol><h3 id="向-IO-Device-read-write"><a href="#向-IO-Device-read-write" class="headerlink" title="向 IO Device read/write"></a>向 IO Device read/write</h3><p>先來看怎麼對 IO device 讀寫。</p><p>CPU 與 IO device 相連，CPU 要能控制 IO device 當然有向 device 發送訊號與從 device 接收訊號的指令。</p><p>向 device 發送訊號的指令是 <code>OUT</code>，反之從 device 接收訊號的指令是 <code>IN</code>。就像 memory 用 memory address 區分不同位置，device 以 device port 區分不同 device。組語實作從 device read 與 write 到 device 的 function 們：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">; read 8 bit</span><br><span class="line">_io_in8:    ; int io_in8(int port);</span><br><span class="line">        MOV        EDX,[ESP+4]    ;<span class="built_in"> port </span>(port number 只有 16 bit)</span><br><span class="line">        MOV        EAX,0           ; 把 return value 清成 0</span><br><span class="line">        <span class="keyword">IN</span>        AL,DX           ; read 8 bit (AL)</span><br><span class="line">        RET                             ; EAX 的值是 return value</span><br><span class="line"></span><br><span class="line">_io_in16:    ; int io_in16(int port);</span><br><span class="line">        MOV        EDX,[ESP+4]    ; port</span><br><span class="line">        MOV        EAX,0</span><br><span class="line">        <span class="keyword">IN</span>        AX,DX           ; read 16 bit (AX)</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">_io_in32:    ; int io_in32(int port);</span><br><span class="line">        MOV        EDX,[ESP+4]    ; port</span><br><span class="line">        <span class="keyword">IN</span>        EAX,DX          ; read 32 bit (EAX)</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">; write 8 bit</span><br><span class="line">_io_out8:    ; void io_out8(int port, int data);</span><br><span class="line">        MOV        EDX,[ESP+4]        ; port</span><br><span class="line">        MOV        AL,[ESP+8]        ; data</span><br><span class="line">        OUT        DX,AL</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">_io_out16:    ; void io_out16(int port, int data);</span><br><span class="line">        MOV        EDX,[ESP+4]        ; port</span><br><span class="line">        MOV        EAX,[ESP+8]        ; data</span><br><span class="line">        OUT        DX,AX</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">_io_out32:    ; void io_out32(int port, int data);</span><br><span class="line">        MOV        EDX,[ESP+4]        ; port</span><br><span class="line">        MOV        EAX,[ESP+8]        ; data</span><br><span class="line">        OUT        DX,EAX</span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>我們要設定調色板，就是找出對應 device 設定調色板的指令，然後照著做～</p><h3 id="CLI-與-STI"><a href="#CLI-與-STI" class="headerlink" title="CLI 與 STI"></a>CLI 與 STI</h3><p><code>CLI</code> 是將 interrupt flag clear 為 0 的指令， <code>STI</code> 則是將 interrupt flag set 為 1 的指令。</p><p>interrupt flag 為 0 時，CPU 遇到 interrupt 會忽略它、不處理，flag 為 1 時 CPU 就會處理 interrupt。</p><h3 id="EFLAGS-register"><a href="#EFLAGS-register" class="headerlink" title="EFLAGS register"></a>EFLAGS register</h3><p><code>EFLAGS</code> 是由 <code>FLAGS</code> 16 bit 的 register 擴展而來的 32 bit register。</p><p><code>FLAGS</code> 儲存 carry flag（進位 flag）與 interrupt flag 等 flag，不同 bit 代表不同 flag（有 1 個 bit 表示一個 flag 也有 2 個 bit），如下所示：</p><table><thead><tr><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td>NT</td><td>IOPL</td><td>IOPL</td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><p><code>IOPL</code> 是第 12 跟 13 bit 放在一起處理。</p><p>EFLAGS 沒有 <code>MOV</code> 指令，只能使用 <code>PUSHFD</code> 跟 <code>POPFD</code> 來讀寫。</p><p><code>PUSHFD</code> 是 push flags double-word 的縮寫，以 double word 的長度（32 bit）將 flag 的值 push 進 stack，等同 <code>PUSH EFLAGS</code>。<code>POPFD</code> 是 pop flags double-word，將 double word 長度的值從 stack pop 出來到 flag，等同 <code>POP EFLAGS</code>。</p><p>如果想把 <code>EFLAGS</code> 內的資料放到 <code>EAX</code> 裡，不能用 <code>MOV</code>，而要先 <code>PUSHFD</code> 再 <code>POP EAX</code>。反過來想把 <code>EAX</code> 的資料放進 <code>EFLAGS</code> 裡則是 <code>PUSH EAX</code> 再 <code>POPFD</code>。操作 <code>EFLAGS</code> 的組語 code 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_io_load_eflags:    ; int io_load_eflags(void);</span><br><span class="line">        PUSHFD        ; PUSH EFLAGS</span><br><span class="line">        POP        EAX</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">_io_store_eflags:    ; void io_store_eflags(int eflags);</span><br><span class="line">        MOV        EAX,[ESP+4]</span><br><span class="line">        PUSH    EAX</span><br><span class="line">        POPFD        ; POP EFLAGS</span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>設定調色盤要先執行 <code>CLI</code>，為了在設定完後恢復 interrupt flag 的值，要先把原本的值記下來。我們可以直接把整個 eflags 記下來、執行 <code>CLI</code>、設定調色盤，最後直接把整個 eflags 的值再存回去，達到恢復 interrupt flag 的效果。</p><h2 id="在螢幕上畫圖"><a href="#在螢幕上畫圖" class="headerlink" title="在螢幕上畫圖"></a>在螢幕上畫圖</h2><p>螢幕上每個像素都對應到 VRAM 中的一個 address。向 VRAM 指定值，便能指定螢幕上像素的顏色。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這天很多在介紹 C，尤其是 pointer，作者用組語的角度去看 C，很有趣。這邊只寫些簡單的筆記。&lt;/p&gt;
&lt;p&gt;組語跟 C 一起使用時，只有 &lt;code&gt;EAX&lt;/code&gt;、&lt;code&gt;ECX&lt;/code&gt;、&lt;code&gt;EDX&lt;/code&gt; 三個 register 可</summary>
      
    
    
    
    <category term="30 天自製作業系統" scheme="http://www.cjwind.idv.tw/categories/30-%E5%A4%A9%E8%87%AA%E8%A3%BD%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
    <category term="OS" scheme="http://www.cjwind.idv.tw/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Day 3 進入 32 bit 模式並導入 C 語言</title>
    <link href="http://www.cjwind.idv.tw/30dayos/day3/"/>
    <id>http://www.cjwind.idv.tw/30dayos/day3/</id>
    <published>2020-04-25T13:59:46.000Z</published>
    <updated>2020-08-09T03:17:09.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="製作真正的-IPL"><a href="#製作真正的-IPL" class="headerlink" title="製作真正的 IPL"></a>製作真正的 IPL</h2><p>IPL 是 Initial Program Loader，現在要開始做真正的 IPL──把磁碟上的東西 load 到 memory 裡！</p><p>這部分書上是一點一點的增加 assembly code，從讀一個 sector 到讀多個 cylinder 的所有 sector。</p><h3 id="floppy-disk-的-cylinder、sector"><a href="#floppy-disk-的-cylinder、sector" class="headerlink" title="floppy disk 的 cylinder、sector"></a>floppy disk 的 cylinder、sector</h3><p>floppy disk 的磁片由外而內的一個個同心圓稱為 cylinder（柱面），共有 80 個 cylinder。由圓心往外切（像切蛋糕），cylinder 切成一格格的稱為 sector，一個 cylinder 有 18 個 sector。磁片正反面都可以存放資料，因此磁頭有正反面，以 0 跟 1 表示。</p><p>一張磁片共有 <code>2 * 80 * 18</code> 個 sector，每個 sector 是 512 byte，所以一張磁片的容量是 <code>2 * 80 * 18 * 512 = 1474560 byte = 1440 KB</code>。<em>就是古早時代的 3.5 磁片…現在應該有些人都不知道那是什麼了…</em></p><p>指定某個 sector 需要指定磁頭、cylinder 編號以及 sector 編號。</p><p><img src="/images/30dayos/floppy_disk.jpg" alt="floppy disk"></p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>JC：jump if carry<ul><li>如果 carry flag 是 1 就 jump</li><li>carry flag 是個只能存一個 bit 的 register，通常用於表示計算有無進位，也會被一些 BIOS function 用來表示回傳值。</li></ul></li><li>JNC：jump if not carry<ul><li>JC 的相反囉</li></ul></li><li>JAE：jump if above or equal<ul><li>大於等於時 jump</li></ul></li><li>JBE：jump if below or equal</li><li>JB：jump if below</li><li>EQU<ul><li>相當於 C 的 <code>#define</code> ，可以用來宣告 const</li><li><code>CYLS EQU 10</code> 就是 <code>CYLS = 10</code> 的意思</li></ul></li></ul><h3 id="Segment-Register"><a href="#Segment-Register" class="headerlink" title="Segment Register"></a>Segment Register</h3><p>一個 16 bit register 的值的範圍是 0 ~ 65535，只能表示 64 KB 的 memory address。在還沒有 32 bit register 的時代用 segment register 來表示更多 memory address。</p><p>使用 segment register 時，以 <code>ES:BX</code> 表示 <code>ES * 16 + BX</code> 的 memory address，在指令裡寫成 <code>MOV AL, [ES:BX]</code>。實際上指定 memory address 時都需要指定 segment register。省略 segment register 會預設使用 <code>DS</code> register，所以寫 <code>MOV CX, [1234]</code> 實際上是 <code>MOV CS, [DS:1234]</code> 。</p><p>因為 <code>ES:BX</code> 表示 memory address <code>ES * 16 + BX</code>，如果想將 address 往前移動 512 byte，可以在 ES 加上 <code>512 / 16 = 32 = 0x20</code>。</p><h3 id="IPL-主要-read-disk-的部分"><a href="#IPL-主要-read-disk-的部分" class="headerlink" title="IPL 主要 read disk 的部分"></a>IPL 主要 read disk 的部分</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">CYLS    <span class="built_in">EQU</span>        <span class="number">10</span>                <span class="comment">; 宣告常數 CYLS = 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; (中略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; read disk</span></span><br><span class="line"><span class="keyword">MOV</span>        <span class="built_in">AX</span>,<span class="number">0x0820</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="number">CH</span>,<span class="number">0</span>            <span class="comment">; cylinder 0</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="number">DH</span>,<span class="number">0</span>            <span class="comment">; 磁頭 0</span></span><br><span class="line">        <span class="comment">; sector 2, 因為 floppy disk 第一個 sector 是 boot sector, 所以從第二個 sector 開始 read</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">CL</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">readloop:</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">SI</span>,<span class="number">0</span>            <span class="comment">; 紀錄失敗次數的 register</span></span><br><span class="line"><span class="symbol">retry:</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="number">AH</span>,<span class="number">0x02</span>            <span class="comment">; AH=0x02 : read floppy disk</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">AL</span>,<span class="number">1</span>            <span class="comment">; 1 sector</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">DL</span>,<span class="number">0x00</span>            <span class="comment">; A 驅動器</span></span><br><span class="line">        <span class="keyword">INT</span>        <span class="number">0x13</span>            <span class="comment">; call BIOS</span></span><br><span class="line">        <span class="keyword">JNC</span>        next            <span class="comment">; 沒出錯就跳到 next</span></span><br><span class="line">        <span class="keyword">ADD</span>        <span class="built_in">SI</span>,<span class="number">1</span>            <span class="comment">; SI + 1 (這段開始在做 retry)</span></span><br><span class="line">        <span class="keyword">CMP</span>        <span class="built_in">SI</span>,<span class="number">5</span>            <span class="comment">; SI 跟 5 比較</span></span><br><span class="line">        <span class="keyword">JAE</span>        error            <span class="comment">; SI &gt;= 5 就跳到 error</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="number">AH</span>,<span class="number">0x00</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">DL</span>,<span class="number">0x00</span>            <span class="comment">; A 驅動器</span></span><br><span class="line">        <span class="keyword">INT</span>        <span class="number">0x13</span>            <span class="comment">; 重置驅動器</span></span><br><span class="line">        <span class="keyword">JMP</span>        retry            <span class="comment">; 回到 retry 再嘗試讀一次</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">AX</span>,<span class="built_in">ES</span>            <span class="comment">; 將 memory address 往後移 0x200 (512)</span></span><br><span class="line">        <span class="keyword">ADD</span>        <span class="built_in">AX</span>,<span class="number">0x0020</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">ES</span>,<span class="built_in">AX</span>            <span class="comment">; 因為沒有 ADD ES,0x020 的指令所以用比較迂迴的方式做</span></span><br><span class="line">        <span class="keyword">ADD</span>        <span class="built_in">CL</span>,<span class="number">1</span>            <span class="comment">; CL + 1 (sector)</span></span><br><span class="line">        <span class="keyword">CMP</span>        <span class="built_in">CL</span>,<span class="number">18</span>            <span class="comment">; CL 跟 18 比較</span></span><br><span class="line">        <span class="keyword">JBE</span>        readloop        <span class="comment">; CL &lt;= 18 則跳到 readloop (這邊就是 read 到 sector 18 的 loop)</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">CL</span>,<span class="number">1</span>            <span class="comment">; CL = 1</span></span><br><span class="line">        <span class="keyword">ADD</span>        <span class="number">DH</span>,<span class="number">1</span>            <span class="comment">; DH + 1</span></span><br><span class="line">        <span class="keyword">CMP</span>        <span class="number">DH</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">JB</span>        readloop        <span class="comment">; DH &lt; 2 則跳到 readloop (這邊是 read 另一個磁頭的 loop)</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="number">DH</span>,<span class="number">0</span>            <span class="comment">; 回到磁頭 0</span></span><br><span class="line">        <span class="keyword">ADD</span>        <span class="number">CH</span>,<span class="number">1</span>            <span class="comment">; CH + 1 (cylinder + 1)</span></span><br><span class="line">        <span class="keyword">CMP</span>        <span class="number">CH</span>,CYLS</span><br><span class="line">        <span class="keyword">JB</span>        readloop        <span class="comment">; CH &lt; CYLS 則跳到 readloop (這邊是 read cylinder 的 loop, CYLS 是常數)</span></span><br></pre></td></tr></table></figure><p>到這裡，我們就有一個將 floppy disk 資料讀到 memory 的 IPL 了！</p><h2 id="最簡單的-OS"><a href="#最簡單的-OS" class="headerlink" title="最簡單的 OS"></a>最簡單的 OS</h2><p>IPL 寫好，當然要來寫 OS 啦！</p><p>在這個部分，無論是切換 video mode、從 BIOS 取得各種資料、把一些資訊保存在 memory 中等等，都是由組語寫成的 <code>haribote.nas</code> —— 我們最簡單的 OS 程式，像這樣一個什麼事也沒幹的 OS：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">fin:</span></span><br><span class="line">        HLT</span><br><span class="line">        <span class="keyword">JMP</span>        fin</span><br></pre></td></tr></table></figure><h3 id="從-boot-sector-執行-OS"><a href="#從-boot-sector-執行-OS" class="headerlink" title="從 boot sector 執行 OS"></a>從 boot sector 執行 OS</h3><p>首先透過 image file 了解在 floppy disk 上檔案是怎麼被放置的（放在哪些位置）。image file 可以想成是把 disk 上的 data「原封不動」的一個個 bit 存下來而成的一個檔案。</p><p>利用 image file 我們知道在 floppy disk 的一個檔案，檔名會寫在 <code>0x002600</code> 後（這裡的 address 是 disk 上的 address），檔案內容會在 <code>0x004200</code> 後。</p><p>所以我們把 OS 內容寫到名為 <code>haribote.sys</code> 的檔案中並存到 floppy disk，它的內容會在 <code>0x004200</code> 之後，所以我們只要從 boot sector 去執行這個位置上的東西就行了！</p><p>要怎麼去執行 disk 上 <code>0x004200</code> 後的程式呢？現在的程式是從 boot sector 開始，把 floppy disk 上的東西 load 到 memory address <code>0x8000</code> ，所以 disk 上 <code>0x4200</code> 的內容會位於 memory address <code>0x8000 + 0x4200 = 0xc200</code> 。</p><p>所以我們在 OS 程式加上 <code>ORG 0xc200</code> ，並且在 IPL 的最後加上 <code>JMP 0xc200</code> ，讓 IPL 完成工作後跳到 OS 程式所在位置開始執行！</p><h3 id="切換顯示模式（video-mode）"><a href="#切換顯示模式（video-mode）" class="headerlink" title="切換顯示模式（video mode）"></a>切換顯示模式（video mode）</h3><p>切換 video mode 的 BIOS 可以參考 <a href="http://oswiki.osask.jp/?(AT)BIOS">BIOS 網頁</a>知道要用哪些 register（雖然是日文的）。</p><p>VRAM 是 video RAM，用來顯示畫面的 memory。它的每個 address 都對應畫面上的像素，在這塊 memory 裡填值就能在畫面上畫東西～VRAM 在 memory 中有好幾塊，分別給不同 video mode 使用。</p><h3 id="進入-32-bit-mode-前的準備"><a href="#進入-32-bit-mode-前的準備" class="headerlink" title="進入 32 bit mode 前的準備"></a>進入 32 bit mode 前的準備</h3><p>32 bit mode 是 CPU 的 mode。不同 mode 有不同 instruction，所以 16 bit 跟 32 bit 的程式是不相容的。register 使用上的方便程度也不同（例如在 16 bit mode 可以方便使用 register AX，但 EAX 不好用）。另外 CPU 的保護功能（識別出可疑的 machine code 並屏蔽它）要在 32 bit mode 才能用。</p><p>不過 32 bit mode 不能使用 BIOS 功能，因為 BIOS 是用 16 bit mode 的 instruction 寫的。如果有什麼是想用 BIOS 做，要一開始先做。</p><p><em>後來出了想取代 BIOS 的 UEFI，又是另一回事了…</em></p><h2 id="導入-C-語言"><a href="#導入-C-語言" class="headerlink" title="導入 C 語言"></a>導入 C 語言</h2><p>終於開始要用 C 語言啦～在這之前得在 <code>haribote.nas</code> 加入一些組語 code，好讓我們能 call C 程式，不過作者在這裡還不想解釋那段，所以也先略過。</p><p>現在 OS 開始有組語跟 C 語言的部分，先將組語部分的 <code>haribote.nas</code> rename 成 <code>asmhead.has</code>。再加入一個很簡單的 C 程式叫 <code>bootpack.c</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程式是從這個 function 開始的，function name 不能更改，應該跟處理 C 語言的組語有關</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HariMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fin:</span><br><span class="line">    <span class="keyword">goto</span> fin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何將它變成可以在我們自製 OS 上執行的 machine code？</p><ol><li>使用 <code>cc1.exe</code> 從 <code>bootpack.c</code> 產生 <code>bootpack.gas</code><br> <code>cc1.exe</code> 是作者用 gcc 改造而來的 C compiler。gcc 是以 gas 組語為基礎，它 output 的是 gas 的 source code。<a href="https://en.wikipedia.org/wiki/GNU_Assembler">gas</a> 是 GNU 的 assembler。</li><li>用 <code>gas2nask.exe</code> 將 <code>bootpack.gas</code> 轉成 <code>bootpack.nas</code><br> 作者使用 nask 當 assembler，所以得把 gas 組語轉成 nask 組語。</li><li>用 <code>nask.exe</code> 將 <code>bootpack.nas</code> 組譯為 <code>bootpack.obj</code></li><li>用 <code>obi2bim.exe</code> 從 <code>bootpack.obj</code> 產生 <code>bootpack.bim</code><ul><li><code>obi2bim.exe</code> 是 linker，這邊是將 object file <code>bootpack.obj</code> link 成完整的 machine code。</li><li>雖然現在只有一個 object file，不是多個 object file 要 link 在一起。但即使只有一個 object file 也要幫它加些資訊才能成為完整可執行的 machine code，所以需要 link。</li><li><code>bim</code> 是作者設計的一種格式，是種 binary image file。</li></ul></li><li>最後用 <code>bim2hrb.exe</code> 從 <code>bootpack.bim</code> 產生 <code>bootpack.hrb</code><br> 這是將 <code>bootpack.bim</code> 依照我們自製 OS 的需要做點加工，成為最後的 <code>bootpack.hrb</code></li></ol><p>到這裡終於把 C 語言程式編譯成可以在自製 OS 上執行的 machine code，最後用 <code>copy</code> 指令將 <code>asmhead.nas</code> 組譯出來的 <code>asmhead.bin</code> 跟 <code>bootpack.hrb</code> 結合起來，成為最終的 <code>haribote.sys</code> 。（原本 <code>haribote.sys</code> 是直接由 <code>haribote.nas</code> 組譯而來，現在有了 C 語言的部分，要把兩個部分結合起來才是完整的 <code>haribote.sys</code> ）</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOOLPATH = ../z_tools/</span><br><span class="line">INCPATH  = ../z_tools/haribote/</span><br><span class="line"></span><br><span class="line">MAKE     = <span class="variable">$(TOOLPATH)</span>make.exe -r</span><br><span class="line">NASK     = <span class="variable">$(TOOLPATH)</span>nask.exe</span><br><span class="line">CC1      = <span class="variable">$(TOOLPATH)</span>cc1.exe -I<span class="variable">$(INCPATH)</span> -Os -Wall -quiet</span><br><span class="line">GAS2NASK = <span class="variable">$(TOOLPATH)</span>gas2nask.exe -a</span><br><span class="line">OBJ2BIM  = <span class="variable">$(TOOLPATH)</span>obj2bim.exe</span><br><span class="line">BIM2HRB  = <span class="variable">$(TOOLPATH)</span>bim2hrb.exe</span><br><span class="line">RULEFILE = <span class="variable">$(TOOLPATH)</span>haribote/haribote.rul</span><br><span class="line">EDIMG    = <span class="variable">$(TOOLPATH)</span>edimg.exe</span><br><span class="line">IMGTOL   = <span class="variable">$(TOOLPATH)</span>imgtol.com</span><br><span class="line">COPY     = copy</span><br><span class="line">DEL      = del</span><br><span class="line"></span><br><span class="line">default :</span><br><span class="line">    <span class="variable">$(MAKE)</span> img</span><br><span class="line"></span><br><span class="line">; 組譯 IPL</span><br><span class="line">ipl10.bin : ipl10.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> ipl10.nas ipl10.bin ipl10.lst</span><br><span class="line"></span><br><span class="line">; 組譯 OS 前面的組語部分</span><br><span class="line">asmhead.bin : asmhead.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> asmhead.nas asmhead.bin asmhead.lst</span><br><span class="line"></span><br><span class="line">; 使用 cc1 compile bootpack.c 得到 gas 組語</span><br><span class="line">bootpack.gas : bootpack.c Makefile</span><br><span class="line">    <span class="variable">$(CC1)</span> -o bootpack.gas bootpack.c</span><br><span class="line"></span><br><span class="line">; 將 gas 組語轉成 nask 組語</span><br><span class="line">bootpack.nas : bootpack.gas Makefile</span><br><span class="line">    <span class="variable">$(GAS2NASK)</span> bootpack.gas bootpack.nas</span><br><span class="line"></span><br><span class="line">; nask 組譯</span><br><span class="line">bootpack.obj : bootpack.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> bootpack.nas bootpack.obj bootpack.lst</span><br><span class="line"></span><br><span class="line">; linking</span><br><span class="line">bootpack.bim : bootpack.obj Makefile</span><br><span class="line">    <span class="variable">$(OBJ2BIM)</span> @<span class="variable">$(RULEFILE)</span> out:bootpack.bim stack:3136k map:bootpack.map \</span><br><span class="line">        bootpack.obj</span><br><span class="line"><span class="comment"># 3MB+64KB=3136KB</span></span><br><span class="line"></span><br><span class="line">; 幫 bootpack.bim 做點加工好能在我們的 OS 上執行</span><br><span class="line">bootpack.hrb : bootpack.bim Makefile</span><br><span class="line">    <span class="variable">$(BIM2HRB)</span> bootpack.bim bootpack.hrb 0</span><br><span class="line"></span><br><span class="line">; 將兩個部份的 machine code 結合在一起</span><br><span class="line">haribote.sys : asmhead.bin bootpack.hrb Makefile</span><br><span class="line">    copy /B asmhead.bin+bootpack.hrb haribote.sys</span><br><span class="line"></span><br><span class="line">; 將 IPL 跟 OS 的 machine code 做成 floopy disk 的 image file</span><br><span class="line">haribote.img : ipl10.bin haribote.sys Makefile</span><br><span class="line">    <span class="variable">$(EDIMG)</span>   imgin:../z_tools/fdimg0at.tek \</span><br><span class="line">        wbinimg src:ipl10.bin len:512 from:0 to:0 \</span><br><span class="line">        copy from:haribote.sys to:@: \</span><br><span class="line">        imgout:haribote.img</span><br><span class="line"></span><br><span class="line">img :</span><br><span class="line">    <span class="variable">$(MAKE)</span> haribote.img</span><br><span class="line"></span><br><span class="line">run :</span><br><span class="line">    <span class="variable">$(MAKE)</span> img</span><br><span class="line">    <span class="variable">$(COPY)</span> haribote.img ..\z_tools\qemu\fdimage0.bin</span><br><span class="line">    <span class="variable">$(MAKE)</span> -C ../z_tools/qemu</span><br><span class="line"></span><br><span class="line">install :</span><br><span class="line">    <span class="variable">$(MAKE)</span> img</span><br><span class="line">    <span class="variable">$(IMGTOL)</span> w a: haribote.img</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.bin</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.lst</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.gas</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.obj</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.nas</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.map</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.bim</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.hrb</span><br><span class="line">    -<span class="variable">$(DEL)</span> haribote.sys</span><br><span class="line"></span><br><span class="line">src_only :</span><br><span class="line">    <span class="variable">$(MAKE)</span> clean</span><br><span class="line">    -<span class="variable">$(DEL)</span> haribote.img</span><br></pre></td></tr></table></figure><h2 id="在-C-語言程式-call-組語程式"><a href="#在-C-語言程式-call-組語程式" class="headerlink" title="在 C 語言程式 call 組語程式"></a>在 C 語言程式 call 組語程式</h2><p>如果想在 C 語言寫的程式 call 組語的程式該怎麼做呢？寫了個組語程式 <code>naskfunc.nas</code> 如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">FORMAT</span> &quot;WCOFF&quot;]            ; 製作 <span class="keyword">object</span> file 的模式</span><br><span class="line">[BITS <span class="number">32</span>]                ; 製作 <span class="number">32</span> <span class="type">bit</span> mode 用的 machine code</span><br><span class="line"></span><br><span class="line">; 製作 <span class="keyword">object</span> file 的資訊</span><br><span class="line"></span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]            ; source code file <span class="type">name</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">GLOBAL</span>    _io_hlt            ; 程式中包含的 <span class="keyword">function</span> <span class="type">name</span></span><br><span class="line"></span><br><span class="line">; 以下是實際 <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">[SECTION .text]</span><br><span class="line"></span><br><span class="line">_io_hlt:    ; <span class="type">void</span> io_hlt(<span class="type">void</span>);</span><br><span class="line">    HLT</span><br><span class="line">    RET    ; 相當於 C 語言的 <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>這段組語包含一個 <code>_io_hlt</code> function。</p><p>在 nask object file 模式下，要設定 file name 資訊並且寫清楚程式的 function name。function name 要在前面加上 <code>_</code> ，不然不能跟 C 語言 function link。需要 link 的 function name 都要用 <code>GLOBAL</code> 指令宣告。</p><p>來看看在 C 語言裡要怎麼使用 <code>_io_hlt</code> function：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告訴 C compiler，這個 function 在別的 file 裡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_hlt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HariMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fin:</span><br><span class="line">    io_hlt();</span><br><span class="line">    <span class="keyword">goto</span> fin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊的 Makefile 跟前面的差異只有增加了 <code>naskfunc.obj</code> 的 target 跟修改 <code>bootpack.bim</code> target 的 link 內容：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">naskfunc.obj : naskfunc.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> naskfunc.nas naskfunc.obj naskfunc.lst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多 link naskfunc.obj</span></span><br><span class="line">bootpack.bim : bootpack.obj naskfunc.obj Makefile</span><br><span class="line">    <span class="variable">$(OBJ2BIM)</span> @<span class="variable">$(RULEFILE)</span> out:bootpack.bim stack:3136k map:bootpack.map \</span><br><span class="line">        bootpack.obj naskfunc.obj</span><br></pre></td></tr></table></figure><p>到這天結束，我們已經有以下 source code：</p><ul><li><code>ipl10.nas</code>：IPL 程式</li><li><code>asmhead.nas</code>：OS 的組語部份</li><li><code>bootpack.c</code>：OS 的 C 語言部份</li><li><code>naskfunc.nas</code>：給 C 語言部份使用的組語 function</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;製作真正的-IPL&quot;&gt;&lt;a href=&quot;#製作真正的-IPL&quot; class=&quot;headerlink&quot; title=&quot;製作真正的 IPL&quot;&gt;&lt;/a&gt;製作真正的 IPL&lt;/h2&gt;&lt;p&gt;IPL 是 Initial Program Loader，現在要開始做真正的 IPL</summary>
      
    
    
    
    <category term="30 天自製作業系統" scheme="http://www.cjwind.idv.tw/categories/30-%E5%A4%A9%E8%87%AA%E8%A3%BD%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
    <category term="OS" scheme="http://www.cjwind.idv.tw/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Day 2 組合語言學習與 Makefile 入門</title>
    <link href="http://www.cjwind.idv.tw/30dayos/day2/"/>
    <id>http://www.cjwind.idv.tw/30dayos/day2/</id>
    <published>2020-04-14T13:55:35.000Z</published>
    <updated>2020-08-09T03:17:09.264Z</updated>
    
    <content type="html"><![CDATA[<p>來解釋這段組語在幹嘛~</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; hello-os</span></span><br><span class="line"><span class="comment">; TAB=4</span></span><br><span class="line"></span><br><span class="line">        ORG        <span class="number">0x7c00</span>            <span class="comment">; 指明程式的 load 位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 以下的記述用於標準 FAT12 格式的磁片</span></span><br><span class="line">        <span class="keyword">JMP</span>        entry</span><br><span class="line">        <span class="built_in">DB</span>        <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">--- (中略) ---</span><br><span class="line"></span><br><span class="line"><span class="comment">; 程式核心</span></span><br><span class="line"><span class="symbol">entry:</span>                            <span class="comment">; label</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">AX</span>,<span class="number">0</span>            <span class="comment">; initialize register</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">SS</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">SP</span>,<span class="number">0x7c00</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">SI</span>,msg            <span class="comment">; SI = msg 的 address</span></span><br><span class="line"><span class="symbol">putloop:</span></span><br><span class="line">        <span class="comment">; 將 memory address 為 SI register 值的資料 assign 給 AL</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">AL</span>,[<span class="built_in">SI</span>]            </span><br><span class="line">        <span class="keyword">ADD</span>        <span class="built_in">SI</span>,<span class="number">1</span>            <span class="comment">; SI + 1</span></span><br><span class="line">        <span class="keyword">CMP</span>        <span class="built_in">AL</span>,<span class="number">0</span>            <span class="comment">; 比較 AL 的值是否為 0</span></span><br><span class="line">        <span class="keyword">JE</span>        fin</span><br><span class="line">        <span class="keyword">MOV</span>        <span class="number">AH</span>,<span class="number">0x0e</span>            <span class="comment">; 顯示一個文字</span></span><br><span class="line">        <span class="keyword">MOV</span>        <span class="built_in">BX</span>,<span class="number">15</span>            <span class="comment">; 指定文字顏色</span></span><br><span class="line">        <span class="keyword">INT</span>        <span class="number">0x10</span>            <span class="comment">; call 顯卡 BIOS</span></span><br><span class="line">        <span class="keyword">JMP</span>        putloop</span><br><span class="line"><span class="symbol">fin:</span></span><br><span class="line">        <span class="keyword">HLT</span>                    <span class="comment">; 讓 CPU 停止，等待指令</span></span><br><span class="line">        <span class="keyword">JMP</span>        fin            <span class="comment">; infinite loop</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">msg:</span></span><br><span class="line">        <span class="built_in">DB</span>        <span class="number">0x0a</span>, <span class="number">0x0a</span>        <span class="comment">; 換行兩次</span></span><br><span class="line">        <span class="built_in">DB</span>        <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">        <span class="built_in">DB</span>        <span class="number">0x0a</span>            <span class="comment">; 換行</span></span><br><span class="line">        <span class="built_in">DB</span>        <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>ORG</code> 指令告訴 nask 程式要從指定的 address 開始，即要把程式 load 到 memory 中指定的 address <em>（這裡總有點半懂不懂）</em>。有這個指令時，<a href="30dayos/day1/">Day 1 從計算機結構到組合語言程式入門</a> 提到的 <code>$</code> 不再是 output file 的第幾個 byte，而是代表將要 read 的 memory address。</p><p><code>entry:</code> 是 label，每個 label 都代表一個 address。位置的值是由 assembler 根據 ORG 計算出「label 所在的地方對應的 address」。</p><p><code>MOV</code> 基本上就是 assignment，source 跟 destination 可以是 register、常數或者 memory address。</p><p>CPU 裡比較重要的 register 及其完整名稱：</p><ul><li>AX：accumulator</li><li>CX：counter</li><li>DX：data</li><li>BX：base</li><li>SP：stack pointer</li><li>BP：base pointer</li><li>SI：source index</li><li>DI：destination index</li></ul><p>這些 register 都是 16 bit。</p><p>另外 CPU 還有 8 個 8 bit register：</p><ul><li>AL：accumulator low</li><li>CL：counter low</li><li>DL：data low</li><li>BL：base low</li><li>AH：accumulator high</li><li>CH：counter high</li><li>DH：data high</li><li>BH：base high</li></ul><p>這些 register 是上面其中幾個 16 bit register 的高位跟低位而已，不是額外的 register。</p><p>那 32 bit register 呢？就是 EAX、ECX、EDX、EBX、ESP、EBP、ESI 跟 EDI 啦～也就是 16 bit register 再擴展一倍，實際上 EAX 有一部分是跟 AX 共用的，跟 8 bit register 與 16 bit register 的關係一樣。</p><p><code>MOV</code> 中，以方括號 <code>[ ]</code> 包起來，表示 memory address。</p><p><code>MOV WORD [678], 123</code> 表示把 123 以 WORD 的大小（16 bit）放到 memory address 678 的地方。數字 123 的二進位表示成 16 bit 是 <code>0000000001111011</code> ，低位 byte <code>01111011</code> 會放在 address 678（memory address 小），高位 byte <code>00000000</code> 則會放在 address 679（memory address 大）。</p><p>位元組順序（Endianness）是指資料在 memory 或傳輸過程中 byte 的擺放順序。將資料的低位 byte 放在 memory address 小、高位 byte 放在 memory address 大的擺放方式稱為 Little-Endian。反之，資料低位 byte 放在 memory address 大、高位 byte 放在 memory address 小，稱為 Big-Endian。一般 x86 的機器是使用 Little-Endian。</p><p>指定 address 的方式，除了用常數，也可以用 register 的值。不過不是所有 register 都可以拿來做這件事，只有 BX、BP、SI 跟 DI 可以。所以 <code>MOV AL, BYTE [SI]</code> 是將 SI register 裡的值當作 address 去 memory 取得一個 byte 的資料並將 assign 給 register AL。另外，<code>MOV</code> 指令有個規則：source 跟 destination 的 byte 數必須相同。能放進 AL 的只有 BYTE，所以上面的指令可以省略 <code>BYTE</code> 變成 <code>MOV AL, [SI]</code>。</p><p><code>JE</code>：如果比較結果相等，則 jump 到特定的 address；若不等，則不 jump，繼續做下一個指令。</p><p>BIOS 是讓 OS 開發人員可以使用的各種 function 的集合。可以用指令 <code>INT</code> call 這些 function，它後面是個數字，不同數字代表不同 function，<code>0x10</code> 的功能是控制顯卡。</p><p>使用 BIOS 的 function 跟其他 level 的程式 call function 一樣，查要的功能是用哪個數字（像 function name），接著照 function 定義在各 register 放值（像 function 參數），register 設好後用 <code>INT</code> call function。</p><p><code>HLT</code> 是讓 CPU 進入待機狀態的指令，才不會 infinite loop 瞎跑。</p><p>在整個 memory 裡，有些區域是有特定用途、不能隨便用的。其中 <code>0x00007c00</code> 到 <code>0x00007dff</code> 這段是 boot sector 的 loading address。所以 <code>ORG</code> 指令才要寫 <code>0x00007c00</code> ，把這份程式 load 到那個 address 才會被當作 boot sector 來 run～（至於為什麼要是這個 address……不知道又是誰訂的XD）</p><p>電腦開機時 BIOS 會在可開機 device 中找 boot signature──在 boot sector 裡最後兩個 byte <code>0x55 AA</code>。BIOS 找到這樣的 boot sector，便將 boot sector load 到 memory address <code>0x00007c00</code> 的位置。接著便開始執行剛 load 進來的 boot record。floppy disk 的整個 boot sector 都是可執行 code（除了最後兩個 byte）。hard disk 的 MBR（Master Boot Record）在（硬碟 boot sector）位置 <code>0x0000</code> ~ <code>0x01bd</code> 是可執行 code，接著後面是 parition table（<code>0x01be</code> ~ <code>0x01fd</code>）以及 boot signature（<code>0x01fe</code> ~ <code>0x01ff</code>）。</p><p>因為 BIOS 會把 boot sector load 到 memory address <code>0x00007c00</code>，所以用 <code>ORG</code> 指令就要寫 <code>0x00007c00</code>。這樣組譯出來的 machine code 裡的各個 memory address 才會是對的。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://wiki.osdev.org/Boot_Sequence#Master_Boot_Record">Boot Sequence - Master Boot Record</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;來解釋這段組語在幹嘛~&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; hello-os&lt;/sp</summary>
      
    
    
    
    <category term="30 天自製作業系統" scheme="http://www.cjwind.idv.tw/categories/30-%E5%A4%A9%E8%87%AA%E8%A3%BD%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
    <category term="OS" scheme="http://www.cjwind.idv.tw/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Day 1 從計算機結構到組合語言程式入門</title>
    <link href="http://www.cjwind.idv.tw/30dayos/day1/"/>
    <id>http://www.cjwind.idv.tw/30dayos/day1/</id>
    <published>2020-04-03T14:22:58.000Z</published>
    <updated>2020-08-09T03:17:09.264Z</updated>
    
    <content type="html"><![CDATA[<p>開始看買來放了一陣的<a href="https://www.tenlong.com.tw/products/9787115287960">《30 天自制操作系統》</a>（簡中翻譯日文書），原本以為是本很硬很難啃的 OS 書，沒想到意外有趣！作者有各種各樣的 murmur 跟吐槽滿點。翻譯除了專有名詞，語句上蠻通順的。</p><p>Day 1 直接用 binary editor 幹出一個 hello world OS。</p><p>本書使用的組譯器是作者自己開發的 nask，其中很多語法模仿 NASM。</p><h2 id="nask-指令-amp-符號"><a href="#nask-指令-amp-符號" class="headerlink" title="nask 指令 &amp; 符號"></a>nask 指令 &amp; 符號</h2><ul><li>DB：define byte，直接在 file 裡輸入一個 byte 的內容</li><li>RESB：reserve byte，從現在的位置空出幾個 byte<ul><li>nask 會幫空出來的 byte 填上 <code>0x00</code></li></ul></li><li>DW：define word<ul><li>word 在這邊是 16 bit，2 byte。</li><li>word 長度應該是因機器架構而異。</li></ul></li><li>DD：define double word<ul><li>double word 則是 32 bit，4 byte。</li></ul></li></ul><p>指令中符號 <code>$</code> 代表 file 到目前這行所在的 byte 數。</p><h2 id="術語解釋"><a href="#術語解釋" class="headerlink" title="術語解釋"></a>術語解釋</h2><ul><li>boot sector（啟動區）<ul><li>電腦讀寫磁碟不是一個個 byte 讀寫，而是以 512 byte 為一個單位讀寫。512 byte 稱為一個 sector。</li><li>floppy disk 第一個 sector 稱為 boot sector。<ul><li><em>我猜對硬碟也適用</em></li></ul></li><li>電腦啟動時，會從第一個 sector 讀起，檢查這個 sector 最後兩個 byte 的內容。如果最後兩 byte 是 <code>0x55 AA</code> 則認為這個 sector 的開頭是啟動程序，接著開始執行這個程序。反之，則是沒有啟動程序，會出現啟動錯誤。<ul><li>至於為什麼是 <code>0x55 AA</code> ，就當初的人亂訂的吧……(爆</li></ul></li></ul></li><li>IPL：initial program loader 的縮寫<ul><li>boot sector 只有 512 byte，通常 OS 都放不進去，所以 boot sector 通常是放 load OS 的 loader 程式。</li><li>有時也將 boot sector 稱為 IPL</li></ul></li><li>boot<ul><li>是 bootstrap 的縮寫</li><li>有「自力更生完成任務」的意思（來源是德國《吹牛大王歷險記》）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;開始看買來放了一陣的&lt;a href=&quot;https://www.tenlong.com.tw/products/9787115287960&quot;&gt;《30 天自制操作系統》&lt;/a&gt;（簡中翻譯日文書），原本以為是本很硬很難啃的 OS 書，沒想到意外有趣！作者有各種各樣的 murmur</summary>
      
    
    
    
    <category term="30 天自製作業系統" scheme="http://www.cjwind.idv.tw/categories/30-%E5%A4%A9%E8%87%AA%E8%A3%BD%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
    <category term="OS" scheme="http://www.cjwind.idv.tw/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>ch3 Sensing and Separation</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch3-Sensing-and-Separation/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch3-Sensing-and-Separation/</id>
    <published>2020-02-28T15:27:32.000Z</published>
    <updated>2020-08-09T06:39:59.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-Summary"><a href="#Chapter-Summary" class="headerlink" title="Chapter Summary"></a>Chapter Summary</h1><p>為了能夠測試，有兩個進行解依賴的理由：</p><ul><li>Sense（感測）是指「得知執行某一塊 code 後會有什麼樣的結果、產生什麼影響」<ul><li>著重在「不是簡單可以透過 return value 得知執行結果」的結果類型</li><li>《單元測試》的互動測試</li></ul></li><li>Separation（分離）是想把某段程式邏輯從它所在的地方分離出來，好能夠在測試裡使用</li></ul><h1 id="與《單元測試》比對"><a href="#與《單元測試》比對" class="headerlink" title="與《單元測試》比對"></a>與《單元測試》比對</h1><ul><li>fake object<ul><li>《單元測試》中是各種假物件的通稱，包含 stub、mock object 都是 fake object。</li><li>本書用來 sense 執行某段 code 的影響，比較像《單元測試》裡簡易的 mock object。</li></ul></li><li>mock object<ul><li>兩書的概念一樣，都是互動測試用的。</li></ul></li></ul><h1 id="Murmur"><a href="#Murmur" class="headerlink" title="Murmur"></a>Murmur</h1><p>用不同方式看同一個東西的感覺真有趣～可以互相比較異同～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Chapter-Summary&quot;&gt;&lt;a href=&quot;#Chapter-Summary&quot; class=&quot;headerlink&quot; title=&quot;Chapter Summary&quot;&gt;&lt;/a&gt;Chapter Summary&lt;/h1&gt;&lt;p&gt;為了能夠測試，有兩個進行解依賴的理由</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Refactor" scheme="http://www.cjwind.idv.tw/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>ch2 Working with Feedback</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch2-Working-with-Feedback/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch2-Working-with-Feedback/</id>
    <published>2020-02-28T14:40:55.000Z</published>
    <updated>2020-08-18T15:15:39.070Z</updated>
    
    <content type="html"><![CDATA[<p>《Working Effectively with Legacy Code》對 unit test 跟更高層的 test 概念跟《單元測試》差不多，只是沒特別用 integration test 這個詞而已。</p><p>改 code 的兩種方法：edit and pray 以及 cover and modify XD</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul><li>要用 unit test 保護修改<ul><li>才知道新修改有沒有改對，以及有沒有改壞原本的東西</li><li>跑測試的速度：需要 0.1s 才能跑完的 unit test 就算慢了</li></ul></li><li>修改 legacy code 步驟 overview<ol><li>確定變動點：ch 16、17</li><li>找出測試點：ch 11、12</li><li>解依賴的技術<ul><li>將 code 放進測試時，讓下手的第一刀更安全：ch 23</li><li>解決一般的依賴問題：ch 9、10</li><li>無法寫測試是因為沒解決大型 method 中的依賴：ch 22</li><li>build code 時間太長：ch 7</li></ul></li><li>編寫測試：ch 13</li><li>修改及 refactor<ul><li>如何增加 feature：ch 8</li><li>將 legacy code 變得結構更好：ch 20 ~ 22</li></ul></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《Working Effectively with Legacy Code》對 unit test 跟更高層的 test 概念跟《單元測試》差不多，只是沒特別用 integration test 這個詞而已。&lt;/p&gt;
&lt;p&gt;改 code 的兩種方法：edit and pra</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Refactor" scheme="http://www.cjwind.idv.tw/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>C pointer to pointer</title>
    <link href="http://www.cjwind.idv.tw/C-pointer-to-pointer/"/>
    <id>http://www.cjwind.idv.tw/C-pointer-to-pointer/</id>
    <published>2019-11-09T15:06:04.000Z</published>
    <updated>2020-08-09T06:39:59.427Z</updated>
    
    <content type="html"><![CDATA[<p><code>Object **self</code> 是 C 語言的 pointer to pointer，常用在想在 callee 操作 caller 的資料。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Object</span> <span class="title">Obejct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_object</span><span class="params">(Object **self)</span> </span>&#123; <span class="comment">// call-by-value</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == (*self = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Object)))) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    (*self)-&gt;a = <span class="number">0</span>; </span><br><span class="line">    (*self)-&gt;b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Object *o = <span class="literal">NULL</span>;</span><br><span class="line">    init_object(&amp;o);</span><br><span class="line">    o-&gt;a = <span class="number">9922</span>; </span><br><span class="line">    o-&gt;b = <span class="number">5566</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/c_pointer_to_pointer.jpg" alt="C Pointer to pointer"></p><p>C 語言是 call by value， <code>self</code> 的 value 是 <code>&amp;o</code> 的 value，也就是 <code>o</code> 的 address。在 <code>init_object()</code> 對 <code>self</code>  dereference、用 <code>*self</code> 操作等同用 <code>o</code> 操作，所以 <code>*self = malloc(sizeof(Object))</code> 等同讓 <code>o</code> 指向新 allocate 出來的 memory，而 <code>(*self)-&gt;a</code> 等同 <code>o-&gt;a</code> 。<code>o</code> 是個 <code>Object</code> 的 pointer， <code>o-&gt;a</code> 是它指向的 <code>Object</code> 的 field <code>a</code>，<code>(*self)-&gt;a = 0</code> 是在初始化 <code>main()</code> 中 <code>o</code> pointer 指向的 <code>Object</code>。</p><p>如果不使用 pointer to pointer，像下面這樣會發生什麼事？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_object</span><span class="params">(Object *self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == (self = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Object)))) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    self-&gt;a = <span class="number">0</span>; </span><br><span class="line">    self-&gt;b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Object *o = <span class="literal">NULL</span>;</span><br><span class="line">    init_object(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這時候 <code>self</code> 的 value 是 <code>o</code> 的 value，也就是 <code>NULL</code>。在 <code>init_object()</code> 裡 <code>self</code> 是個 local variable，allocate 一塊 <code>Object</code> 大小的 memory 給它以及其他操作都不會如我們希望的影響到 <code>main()</code> 裡的 <code>o</code> 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Object **self&lt;/code&gt; 是 C 語言的 pointer to pointer，常用在想在 callee 操作 caller 的資料。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;c</summary>
      
    
    
    
    
    <category term="C" scheme="http://www.cjwind.idv.tw/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Go 多維 array 與 slice</title>
    <link href="http://www.cjwind.idv.tw/Go-multi-dimention-array-and-slice/"/>
    <id>http://www.cjwind.idv.tw/Go-multi-dimention-array-and-slice/</id>
    <published>2019-11-09T14:25:56.000Z</published>
    <updated>2020-08-09T06:39:59.427Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Array types are always one-dimensional but may be composed to form multi-dimensional types.</p></blockquote><p>from <a href="https://golang.org/ref/spec#Array_types">spec Array types</a></p><blockquote><p>A slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array.<br>…<br>Like arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects.</p></blockquote><p>from <a href="https://golang.org/ref/spec#Slice_types">spec Slice types</a></p><h1 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>在多維的情況下，inner slice 只能一個個初始化，像這樣：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> x &#123;</span><br><span class="line">    x[i] = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子沒有迴圈直接去 access <code>x[0][0]</code> 的話會 <code>index out of range</code>。</p><p>或者用 literal 直接寫：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [][]<span class="keyword">uint8</span>&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>初始化成零值比較簡單：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := [<span class="number">5</span>][<span class="number">5</span>]<span class="keyword">uint8</span>&#123;&#125;</span><br><span class="line"><span class="comment">// [[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]]</span></span><br></pre></td></tr></table></figure><h1 id="Memory-Size"><a href="#Memory-Size" class="headerlink" title="Memory Size"></a>Memory Size</h1><p>多維 array 的 size 是 <code>type size * element 數量</code> 。</p><p>多維 slice 的 size 則要看多維 slice 是怎麼組成的。slice 由指向 underlying array 的 pointer、length、capacity 組成，多維 slice 不同的組合方式會造成有不同數量的 slice header 而有不同的 size，來個例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 是 2 x 1000 的 slice</span></span><br><span class="line">x := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> x &#123;</span><br><span class="line">    x[i] = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(x), <span class="built_in">len</span>(x)*<span class="built_in">len</span>(x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// y 是 1000 x 2 的 slice</span></span><br><span class="line">y := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> y &#123;</span><br><span class="line">    y[i] = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(y), <span class="built_in">len</span>(y)*<span class="built_in">len</span>(y[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>output 是：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2000</span></span><br><span class="line"><span class="number">1000</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>x 跟 y 都是多維 slice 而且都有 2000 個 element。x 只有兩個 slice、每個 slice 有 1000 個 element byte，y 有 1000 個 slice、每個 slice 只有兩個 element。</p><p>slice header 長這樣：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">    Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>from <a href="https://golang.org/pkg/reflect/#SliceHeader">SliceHeader</a></p><p>在 64-bit 平台上，一個 slice header 的 size 是 24 bytes。那麼 x 的總 size 是 2000 + 2 * 24 = 2048 bytes。而 y 的總 size 則是 2000 + 1000 * 24 = 26000 bytes。</p><p>所以啦，考量 memory 使用的時候，需要注意多維 slice 是怎麼組的，像上面的 y，slice header 的 size 遠超過全部 element 的 size。</p><h1 id="Inner-array-slice-length"><a href="#Inner-array-slice-length" class="headerlink" title="Inner array/slice length"></a>Inner array/slice length</h1><blockquote><p>With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.</p></blockquote><p>多維 array 的 inner array 都是相同 length 的。</p><p>多維 slice 的 inner slice 可以是不同 length。另外，inner slice 必須要各自 initialize。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul><li><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">What is a concise way to create a 2D slice in Go?</a></li><li><a href="https://stackoverflow.com/questions/39561140/how-is-two-dimensional-arrays-memory-representation">How is two dimensional array’s memory representation</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Array types are always one-dimensional but may be composed to form multi-dimensional types.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;from &lt;a hre</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>OpenAPI PSR-7 Message Validator required field</title>
    <link href="http://www.cjwind.idv.tw/OpenAPI-PSR-7-Message-Validator/"/>
    <id>http://www.cjwind.idv.tw/OpenAPI-PSR-7-Message-Validator/</id>
    <published>2019-10-25T14:28:10.000Z</published>
    <updated>2020-08-09T03:17:09.248Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/thephpleague/openapi-psr7-validator">https://github.com/thephpleague/openapi-psr7-validator</a></li></ul><p>如果要驗證 response「要有某個欄位」，在 api 定義（yaml 或 json 檔）裡該欄位要設 <code>required</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/general/test:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">200:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">content:</span></span><br><span class="line">            <span class="attr">application/json:</span></span><br><span class="line">              <span class="attr">schema:</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">                <span class="attr">properties:</span></span><br><span class="line">                  <span class="attr">id:</span></span><br><span class="line">                    <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">                  <span class="attr">username:</span></span><br><span class="line">                    <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">                <span class="attr">required:</span>    <span class="comment"># 沒有這個的話, response 有或沒有這些欄位都會過</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">id</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">username</span></span><br></pre></td></tr></table></figure><p>用 component 的版本：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/general/test:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">200:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">content:</span></span><br><span class="line">            <span class="attr">application/json:</span></span><br><span class="line">              <span class="attr">schema:</span></span><br><span class="line">                <span class="string">\$ref:</span> <span class="string">&#x27;#/components/schemas/User&#x27;</span></span><br><span class="line"><span class="attr">components:</span></span><br><span class="line">  <span class="attr">schemas:</span></span><br><span class="line">    <span class="attr">User:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">object</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">id:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">        <span class="attr">username:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">required:</span> <span class="comment"># 這裡</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">id</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">username</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/thephpleague/openapi-psr7-validator&quot;&gt;https://github.com/thephpleague/openapi-psr7-validator&lt;/a&gt;&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="OpenAPI" scheme="http://www.cjwind.idv.tw/tags/OpenAPI/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下 PhpStorm 輸入中文</title>
    <link href="http://www.cjwind.idv.tw/PhpStorm-input-chinese-in-Linux/"/>
    <id>http://www.cjwind.idv.tw/PhpStorm-input-chinese-in-Linux/</id>
    <published>2019-09-09T15:43:04.000Z</published>
    <updated>2020-08-09T03:17:09.248Z</updated>
    
    <content type="html"><![CDATA[<p>問題：Linux 下的 PhpStorm 無法切換輸入法輸入中文。</p><p>在 PhpStorm 啟動 script <code>bin/phpstorm.sh</code> 的 <code>Run the IDE</code> 前加入：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">XMODIFIERS</span>=<span class="string">&quot;@im=fcitx&quot;</span></span><br><span class="line"><span class="builtin-name">export</span> XMODIFIERS</span><br></pre></td></tr></table></figure><p>這樣用 shell 啟動 PhpStorm 就能切到中文輸入法（前提當然是已經有裝好了），不過從 launcher 啟動 PhpStorm 還是不行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;問題：Linux 下的 PhpStorm 無法切換輸入法輸入中文。&lt;/p&gt;
&lt;p&gt;在 PhpStorm 啟動 script &lt;code&gt;bin/phpstorm.sh&lt;/code&gt; 的 &lt;code&gt;Run the IDE&lt;/code&gt; 前加入：&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://www.cjwind.idv.tw/tags/Linux/"/>
    
    <category term="PhpStorm" scheme="http://www.cjwind.idv.tw/tags/PhpStorm/"/>
    
  </entry>
  
  <entry>
    <title>Get started with Docker Part 5 &amp; 6</title>
    <link href="http://www.cjwind.idv.tw/get-started-with-docker/part-5-6/"/>
    <id>http://www.cjwind.idv.tw/get-started-with-docker/part-5-6/</id>
    <published>2019-08-09T07:43:54.000Z</published>
    <updated>2020-08-09T03:17:09.268Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/">Dodkcer Get Started</a> 隨手記。</p><h2 id="Part-5-Stacks"><a href="#Part-5-Stacks" class="headerlink" title="Part 5: Stacks"></a><a href="https://docs.docker.com/get-started/part5/">Part 5: Stacks</a></h2><blockquote><p>A stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together. A single stack is capable of defining and coordinating the functionality of an entire application (though very complex applications may want to use multiple stacks).</p></blockquote><p>stack 定義了一堆互相有關的 service，把 service 放在一個 stack 裡就可以一起操作、scale 等等。可以用一個 stack 來定義一個 application 的功能，比較複雜的 application 可能有多個 stack。</p><p>也就是可以把 application 拆分成多個 service 來運作，這些 service 可以只跑在一台機器上，也可以在 swarm 中跑在不同機器上。原本要做到這件事，要嘛要在一台機器上裝各種 server，要分散就得在多台機器上裝各自需要的 server，再不然就得裝 VM 起來做這些事，而且也沒有個統一的地方記錄各 service 的版本等等資訊（工人智慧…）。Docker 把 setup 開發及 production 環境跟 scale up 變得簡單很多。</p><h3 id="More-docker-compose-yml"><a href="#More-docker-compose-yml" class="headerlink" title="More docker-compose.yml"></a>More <code>docker-compose.yml</code></h3><p><a href="/Get-started-with-Docker-Part-3/">part 3</a> 寫的 <code>docker-compose.yml</code> 是定義只有一個 service 的 stack。下面是有兩個 service 分別為 <code>visualizer</code> 跟 <code>redis</code> 的 stack：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span>    <span class="comment"># compose file format version</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">visualizer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="comment"># mapping host 的 file 到 container 裡</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="comment"># 指定 service 要 run 在哪個 node</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>]    <span class="comment"># 只能 run 在 swarm manager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">webnet</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># mapping host 的 /home/docker/data 到 container 的 /data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/home/docker/data:/data&quot;</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>]</span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--appendonly</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">webnet:</span></span><br></pre></td></tr></table></figure><p>如果沒有做 volume mapping，container 的 disk 的 file 在 container 重開後會不見。</p><p>其他 compose file 設定可參考：<a href="https://docs.docker.com/compose/compose-file/">Compose file reference</a>。</p><p>修改 <code>docker-compose.yml</code> 後重新 deploy 只需 <code>docker stack deploy -c docker-compose.yml &lt;stack_name&gt;</code>。</p><p>要結束整個 stack 的 service 則 <code>docker stack rm &lt;stack_name&gt;</code>。</p><h2 id="Part-6-Deploy-your-app"><a href="#Part-6-Deploy-your-app" class="headerlink" title="Part 6: Deploy your app"></a><a href="https://docs.docker.com/get-started/part6/">Part 6: Deploy your app</a></h2><p>這篇是看你要用 Docker Enterprise 還是自己裝 <a href="https://docs.docker.com/install/">Docker Engine - Community</a> 進行開發及 deploy production。</p><p>開發環境跟 production 環境的 Docker 操作都一樣（只是執行的地方不一樣。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Dodkcer Get Started&lt;/a&gt; 隨手記。&lt;/p&gt;
&lt;h2 id=&quot;Part-5-Stacks&quot;&gt;&lt;a href=&quot;#Part-5-Stacks&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Get started with Docker" scheme="http://www.cjwind.idv.tw/categories/Get-started-with-Docker/"/>
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Get started with Docker Part 4: Swarms</title>
    <link href="http://www.cjwind.idv.tw/get-started-with-docker/part-4/"/>
    <id>http://www.cjwind.idv.tw/get-started-with-docker/part-4/</id>
    <published>2019-08-06T01:24:50.000Z</published>
    <updated>2020-08-09T03:17:09.268Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/">Dodkcer Get Started</a> 隨手記。</p><h2 id="Part-4-Swarms"><a href="#Part-4-Swarms" class="headerlink" title="Part 4: Swarms"></a><a href="https://docs.docker.com/get-started/part4/">Part 4: Swarms</a></h2><p>這個 part 會 deploy app 到 cluster 並執行在多個 machine 上。</p><p>Linux 要先<a href="https://docs.docker.com/machine/install-machine/#installing-machine-directly">安裝 Docker Machine</a>。</p><h3 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h3><blockquote><p>A swarm is a group of machines that are running Docker and joined into a cluster.</p></blockquote><p>swarm 是一群 cluster 中跑著 Docker 的機器。機器加入 cluster 後，在上面執行的 Docker command 由 swarm manager 在 cluster 中執行。</p><blockquote><p>The machines in a swarm can be physical or virtual. After joining a swarm, they are referred to as <strong>nodes</strong>.</p></blockquote><p>一台加入 swarm 的機器稱為 node。</p><p>swarm 中只有 swarm manager 可以執行 command、讓其他機器加入 swarm 當 <strong>worker</strong>。worker 就只是執行，不能叫其他人做事或讓其他機器加入 swarm。swarm manager 可以用多種策略來執行 container。</p><p>平常 Docker 是在 single-host mode 執行，轉成 swarm mode 才能使用 swarm 相關功能。讓一台機器變成 swarm manager 後，Docker 會將 command 執行在它管理的 swarm 上，而非只在目前的機器。</p><h3 id="Set-up-swarm"><a href="#Set-up-swarm" class="headerlink" title="Set up swarm"></a>Set up swarm</h3><p>用 <code>docker swarm init</code> 把一台機器變成 swarm manager，再到其他要當 worker 的機器上執行 <code>docker swarm join</code>。</p><p>接下來用 VM 建個 cluster。</p><p>因為用 VM，Linux 上要先裝 <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>。</p><p>使用 <code>docker-machine</code> 產生兩台 VM：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm1</span></span><br><span class="line">$ docker-machine <span class="built_in">create</span> <span class="comment">--driver virtualbox myvm2</span></span><br></pre></td></tr></table></figure><p>列出 VM：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS</span><br><span class="line">myvm1   -        virtualbox   Running   tcp:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">99.100</span>:<span class="number">2376</span>           v19.<span class="number">03.1</span></span><br><span class="line">myvm2   -        virtualbox   Running   tcp:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">99.101</span>:<span class="number">2376</span>           v19.<span class="number">03.1</span></span><br></pre></td></tr></table></figure><p>接下來讓 <code>myvm1</code> 當 swarm manager、<code>myvm2</code> 當 worker。</p><p>透過 <code>docker-machine ssh &lt;vm&gt; &quot;&lt;command&gt;&quot;</code> 可以在 VM 上執行指令：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker-machine ssh myvm1 <span class="string">&quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>上面指令會得到將 worker 加入此 swarm 的 command，到 <code>myvm2</code> 上執行：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh myvm2 &quot;docker swarm join --token <span class="tag">&lt;<span class="name">token</span>&gt;</span> <span class="tag">&lt;<span class="name">swarm</span> <span class="attr">manager</span> <span class="attr">ip</span>&gt;</span>:<span class="tag">&lt;<span class="name">port</span>&gt;</span>&quot;</span><br></pre></td></tr></table></figure><p>port 預設是 2377。</p><p>從 <code>myvm1</code> 看 node：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker-machine ssh myvm1 <span class="string">&quot;docker node ls&quot;</span></span><br></pre></td></tr></table></figure><p>最後 node 離開 swarm：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker-machine ssh myvm2 <span class="string">&quot;docker swarm leave&quot;</span></span><br></pre></td></tr></table></figure><h3 id="docker-machine-shell"><a href="#docker-machine-shell" class="headerlink" title="docker-machine shell"></a><code>docker-machine</code> shell</h3><p><code>docker-machine ssh</code> 打起來很長，VM 也無法 access VM host 的檔案。用 <code>docker-machine env &lt;machine&gt;</code> 設定可以讓 shell 直接跟 VM 溝通：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_TLS_VERIFY</span>=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_HOST</span>=<span class="string">&quot;tcp://192.168.99.100:2376&quot;</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_CERT_PATH</span>=<span class="string">&quot;/home/cjw/.docker/machine/machines/myvm1&quot;</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_MACHINE_NAME</span>=<span class="string">&quot;myvm1&quot;</span></span><br><span class="line"><span class="comment"># Run this command to configure your shell:</span></span><br><span class="line"><span class="comment"># eval $(docker-machine env myvm1)</span></span><br></pre></td></tr></table></figure><p>執行 <code>eval $(docker-machine env myvm1)</code>，接著用 <code>docker-machine ls</code> 確認目前 shell active 的 machine（<code>ACTIVE</code> column）：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS</span><br><span class="line">myvm1   *        virtualbox   Running   tcp:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">99.100</span>:<span class="number">2376</span>           v19.<span class="number">03.1</span></span><br><span class="line">myvm2   -        virtualbox   Running   tcp:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">99.101</span>:<span class="number">2376</span>           v19.<span class="number">03.1</span></span><br></pre></td></tr></table></figure><p>之後執行 docker 指令都是在 <code>myvm1</code> 上執行囉！比較方便而且可以 access 到 VM host 的檔案。要換到別的 machine 就再執行一次 <code>docker-machine env &lt;machine&gt;</code> 把 <code>&lt;machine&gt;</code> 換掉即可。</p><h3 id="在-swarm-manager-上-deploy-app"><a href="#在-swarm-manager-上-deploy-app" class="headerlink" title="在 swarm manager 上 deploy app"></a>在 swarm manager 上 deploy app</h3><p>跟 part 3 一樣，只是 part 3 是把本機直接變成 swarm manager，現在 swarm manager 是 <code>myvm1</code>（把它當作遠端）。</p><p>一樣用 <code>docker stack deploy -c docker-compose.yml &lt;stack_name&gt;</code> 來 deploy app。跟 part 3 不同的是現在 service 會分別開在 <code>myvm1</code> 跟 <code>myvm2</code> 上：</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line">$ <span class="string">docker </span><span class="string">service </span><span class="string">ps </span><span class="string">getstartedlab_web</span></span><br><span class="line"><span class="string">ID </span>                 <span class="string">NAME </span>                 <span class="string">IMAGE </span>                     <span class="string">NODE </span>               <span class="string">DESIRED </span><span class="string">STATE </span>      <span class="string">CURRENT </span><span class="string">STATE </span>           <span class="string">ERROR </span>              <span class="string">PORTS</span></span><br><span class="line"><span class="string">hprga9r6s5se </span>       <span class="string">getstartedlab_web.</span>1   <span class="string">cjwind/</span><span class="built_in">get-started:part2</span>   <span class="string">myvm2 </span>              <span class="string">Running </span>            <span class="string">Running </span><span class="string">18 </span><span class="string">minutes </span><span class="string">ago</span></span><br><span class="line"><span class="string">n1bc2c2xosal </span>       <span class="string">getstartedlab_web.</span>2   <span class="string">cjwind/</span><span class="built_in">get-started:part2</span>   <span class="string">myvm1 </span>              <span class="string">Running </span>            <span class="string">Running </span><span class="string">18 </span><span class="string">minutes </span><span class="string">ago</span></span><br><span class="line"><span class="string">rbkv7bctikfq </span>       <span class="string">getstartedlab_web.</span>3   <span class="string">cjwind/</span><span class="built_in">get-started:part2</span>   <span class="string">myvm2 </span>              <span class="string">Running </span>            <span class="string">Running </span><span class="string">18 </span><span class="string">minutes </span><span class="string">ago</span></span><br><span class="line"><span class="string">mr1o60i52f6u </span>       <span class="string">getstartedlab_web.</span>4   <span class="string">cjwind/</span><span class="built_in">get-started:part2</span>   <span class="string">myvm2 </span>              <span class="string">Running </span>            <span class="string">Running </span><span class="string">18 </span><span class="string">minutes </span><span class="string">ago</span></span><br><span class="line"><span class="string">4k7ehhz2nzl3 </span>       <span class="string">getstartedlab_web.</span>5   <span class="string">cjwind/</span><span class="built_in">get-started:part2</span>   <span class="string">myvm1 </span>              <span class="string">Running </span>            <span class="string">Running </span><span class="string">18 </span><span class="string">minutes </span><span class="string">ago</span></span><br></pre></td></tr></table></figure><p>到這裡完成了將 app deploy 到 cluster 上，並且 service 有 load-balanced！</p><h3 id="access-swarm-上的-app"><a href="#access-swarm-上的-app" class="headerlink" title="access swarm 上的 app"></a>access swarm 上的 app</h3><p>可以透過 swarm 中任何一個 node 的 IP 去 access app。這是藉由讓 node 在 ingress routing mesh 裡達到。</p><img src="https://i.imgur.com/UPiyTkX.png" width="800"><p>[<a href="https://docs.docker.com/get-started/part4/">source</a>]</p><p>在 swarm mode 打開前，swarm node 間的 port 7946 TCP/UDP 以及 port 4789 UDP 要開啟，ingress network 才能運作，所以要注意 app 不能佔用這些 port。</p><h3 id="scale-up-in-cluster"><a href="#scale-up-in-cluster" class="headerlink" title="scale up in cluster"></a>scale up in cluster</h3><p>要讓 service 使用更多 node，只要先用 <code>docker swarm join</code> 增加 node，再 <code>docker stack deploy</code>，service 就能使用增加的 node。</p><h3 id="Cleanup"><a href="#Cleanup" class="headerlink" title="Cleanup"></a>Cleanup</h3><p>清掉 <code>docker-machine</code> 的環境變數：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ eval <span class="constructor">$(<span class="params">docker</span>-<span class="params">machine</span> <span class="params">env</span> -<span class="params">u</span>)</span></span><br></pre></td></tr></table></figure><p>結束 stack 的所有 service、刪掉 stack：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> docker stack <span class="built_in">rm</span> &lt;stack_name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Dodkcer Get Started&lt;/a&gt; 隨手記。&lt;/p&gt;
&lt;h2 id=&quot;Part-4-Swarms&quot;&gt;&lt;a href=&quot;#Part-4-Swarms&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Get started with Docker" scheme="http://www.cjwind.idv.tw/categories/Get-started-with-Docker/"/>
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Get started with Docker Part 3: Services</title>
    <link href="http://www.cjwind.idv.tw/get-started-with-docker/part-3/"/>
    <id>http://www.cjwind.idv.tw/get-started-with-docker/part-3/</id>
    <published>2019-08-04T13:56:10.000Z</published>
    <updated>2020-08-09T03:17:09.268Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/">Dodkcer Get Started</a> 隨手記。</p><h2 id="Part-3-Services"><a href="#Part-3-Services" class="headerlink" title="Part 3: Services"></a><a href="https://docs.docker.com/get-started/part3/">Part 3: Services</a></h2><p>Linux 要先<a href="https://docs.docker.com/compose/install/">安裝 Docker Compose</a>，Windows 的 Docker Desktop 已經包含 Docker Compose。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>分散式系統中各 app 都可稱為一個 “service”，儲存資料到 DB、處理 video transcoding 等等都可以是個 “service”。</p><p>Docker 的 services 是一堆在 production 的 containers。一個 service run 一個 image，service 會指定這個 image 要怎麼執行──使用哪些 port、會跑多少 container 等等。只要改變執行的 container instance 數量就能 scale service。透過 <code>docker-compose.yml</code> 定義、執行跟 scale services。</p><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a><code>docker-compose.yml</code></h3><p><code>docker-compose.yml</code> 定義 container 在 production 該有什麼行為。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 這個 service 叫作 web</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="comment"># 從 registry pull image</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cjwind/get-started:part2</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="comment"># run 5 instances</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="comment"># 一個 instance 最多只能使用一個 single core CPU 10% 的 CPU time</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">&quot;0.1&quot;</span></span><br><span class="line">          <span class="comment"># 一個 instance 最多只能用 50MB memory</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">50M</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="comment"># container fail 會立刻 restart</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># map host port 4000 到 service web 的 port 80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4000:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="comment"># 讓 containers 透過 webnet 這個 load-balanced network 共用 host 的 port 80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="comment"># 以預設值（load-balanced overlay network）定義 webnet</span></span><br><span class="line">  <span class="attr">webnet:</span></span><br></pre></td></tr></table></figure><h3 id="執行-service"><a href="#執行-service" class="headerlink" title="執行 service"></a>執行 service</h3><p>跑 service 前要先：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker swarm init</span><br></pre></td></tr></table></figure><p>接著執行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">stack</span> deploy -c docker-compose.yml &lt;stack_name&gt;</span><br><span class="line">$ docker <span class="built_in">stack</span> deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure><p>可以用以下兩個 command 看執行的 service：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker<span class="built_in"> service </span>ls</span><br><span class="line">$ docker stack services &lt;stack_name&gt;</span><br></pre></td></tr></table></figure><p>兩個 command 的結果都是：</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">ID </span>                 <span class="string">NAME </span>               <span class="string">MODE </span>               <span class="string">REPLICAS </span>           <span class="string">IMAGE </span>                     <span class="string">PORTS</span></span><br><span class="line"><span class="string">ylewu1idwhp0 </span>       <span class="string">getstartedlab_web </span>  <span class="string">replicated </span>         5/5                 <span class="string">cjwind/</span><span class="built_in">get-started:part2</span>   *:<span class="string">4000-</span>&gt;<span class="string">80/</span><span class="string">tcp</span></span><br></pre></td></tr></table></figure><blockquote><p>A single container running in a service is called a <strong>task</strong>.</p></blockquote><p>列出 service 的 task：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker<span class="built_in"> service </span>ps &lt;service_name&gt;</span><br><span class="line">$ docker<span class="built_in"> service </span>ps getstartedlab_web</span><br></pre></td></tr></table></figure><p>當然也可以用 <code>docker container ls</code> 看 service 的 running container。</p><p>列出 stack 所有 task：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> docker stack <span class="built_in">ps</span> &lt;stack_name&gt;</span><br><span class="line"><span class="variable">$</span> docker stack <span class="built_in">ps</span> getstartedlab</span><br></pre></td></tr></table></figure><p>service 執行時如果想修改 task 數量，只要修改 <code>docker-compose.yml</code> 的 <code>replicas</code> 設定，再執行一次 <code>docker stack deploy -c docker-compose.yml &lt;stack_name&gt;</code> 就可以了！</p><p>要結束 service，首先關掉 app：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> docker stack <span class="built_in">rm</span> getstartedlab</span><br></pre></td></tr></table></figure><p>離開 swarm：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> docker swarm leave <span class="operator">-f</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Dodkcer Get Started&lt;/a&gt; 隨手記。&lt;/p&gt;
&lt;h2 id=&quot;Part-3-Services&quot;&gt;&lt;a href=&quot;#Part-3-Services&quot; class</summary>
      
    
    
    
    <category term="Get started with Docker" scheme="http://www.cjwind.idv.tw/categories/Get-started-with-Docker/"/>
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Get started with Docker Part 1 &amp; 2</title>
    <link href="http://www.cjwind.idv.tw/get-started-with-docker/part-1-2/"/>
    <id>http://www.cjwind.idv.tw/get-started-with-docker/part-1-2/</id>
    <published>2019-08-03T15:23:44.000Z</published>
    <updated>2020-08-09T03:17:09.268Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.docker.com/get-started/">Dodkcer Get Started</a> 隨手記。</p><h2 id="Part-1-Orientation-and-setup"><a href="#Part-1-Orientation-and-setup" class="headerlink" title="Part 1: Orientation and setup"></a><a href="https://docs.docker.com/get-started/">Part 1: Orientation and setup</a></h2><blockquote><p>Docker is a platform for developers and sysadmins to <strong>develop, deploy, and run</strong> applications with containers.</p></blockquote><blockquote><p>The use of Linux containers to deploy applications is called <em>containerization</em>.</p></blockquote><h3 id="Images-and-containers"><a href="#Images-and-containers" class="headerlink" title="Images and containers"></a>Images and containers</h3><blockquote><p>An <strong>image</strong> is an executable package that includes everything needed to run an application–the code, a runtime, libraries, environment variables, and configuration files.</p></blockquote><blockquote><p>A <strong>container</strong> is a runtime instance of an image–what the image becomes in memory when executed (that is, an image with state, or a user process).</p></blockquote><h3 id="Container-vs-VM"><a href="#Container-vs-VM" class="headerlink" title="Container vs VM"></a>Container vs VM</h3><blockquote><p>A <strong>container</strong> runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.</p></blockquote><p>看起來 container 是 process level 的。</p><blockquote><p>a <strong>virtual machine</strong> (VM) runs a full-blown “guest” operating system with <em>virtual access</em> to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.</p></blockquote><p>用 Docker 可以把 application 需要的環境跟 code 等等包在 image 裡，以此 image 來開發跟 deploy，解決 application 的 system dependency 問題。因為整個環境都包在 Docker 裡了，application 可以在任何有 Docker 環境的地方執行（從 local 到 cloud 等等）。相較 VM，container 比較 light-weight 而且只有 application 需要的環境。</p><h2 id="Part-2-Containers"><a href="#Part-2-Containers" class="headerlink" title="Part 2: Containers"></a><a href="https://docs.docker.com/get-started/part2/">Part 2: Containers</a></h2><p>hierarchy 由高到低：</p><ul><li>Stack：define the interactions of all the services</li><li>Services：defines how containers behave in production</li><li>Container：a runtime instance of an image</li></ul><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><blockquote><p><strong><code>Dockerfile</code></strong> defines what goes on in the environment inside your container.</p></blockquote><p>container 的網路跟 disk drive 是 virtualized、跟外界隔開的，所以要做 port mapping 以及指定哪些檔案要 copy 進 container。</p><p>Dockerfile 指令 [<a href="https://docs.docker.com/engine/reference/builder/">Ref</a>]：</p><ul><li><code>FROM</code> 指定 parent image</li><li><code>WORKDIP</code> 指定 container 內的 working dir</li><li><code>COPY</code> copy 檔案到 container 裡</li><li><code>RUN</code> 執行指令<ul><li><blockquote><p>The RUN instruction will execute any commands in a new layer on top of the current image and commit the results.</p></blockquote></li></ul></li><li><code>EXPOSE</code> 表示 container 會 listen 哪些 port<ul><li>跟 <code>docker run -p</code> 做 port mapping 不同，不會真的 publish port</li><li><blockquote><p>The <code>EXPOSE</code> instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published.</p></blockquote></li><li>寫不寫 <code>EXPOSE</code> 都可以 publish port，<code>EXPOSE</code> 是讓使用 image 的人知道 container 會 listen 哪個 port，好知道怎麼 publish port。</li></ul></li><li><code>ENV</code> 設定環境變數</li><li><code>CMD</code> container 開起來時要執行的指令</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li>在 container 裡拿 hostname 會拿到 container ID</li></ul><h3 id="更多-docker-run"><a href="#更多-docker-run" class="headerlink" title="更多 docker run"></a>更多 <code>docker run</code></h3><ul><li><code>-p &lt;host port&gt;:&lt;container port&gt;</code> publish port，做 host port 跟 container port 的 mapping。[<a href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports">Ref</a>]</li><li><code>-d</code> 以 detach mode 執行 container，就是背景執行啦～</li></ul><p><a href="http://127.0.0.1:4000/PhpStorm-Docker-in-Win10/#Docker-Command-Line-Usage">基本 docker run 使用 Ref</a></p><h3 id="Share-image"><a href="#Share-image" class="headerlink" title="Share image"></a>Share image</h3><blockquote><p>A registry is a collection of repositories, and a repository is a collection of images</p></blockquote><p><code>docker</code> 預設使用的 registry 是 <a href="https://hub.docker.com/">Docker Hub</a>。</p><p>tag 是用來給 image 版本的方式。</p><ol><li>幫 image 加上 registry 的 repository tag：</li></ol><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">tag</span> <span class="variable">&lt;image&gt;</span> <span class="variable">&lt;username&gt;</span>/<span class="variable">&lt;repository&gt;</span>:<span class="variable">&lt;tag&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>publish image：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ docker push <span class="tag">&lt;<span class="name">username</span>&gt;</span>/<span class="tag">&lt;<span class="name">repository</span>&gt;</span>:<span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>pull and run image from remote repository：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ docker run <span class="tag">&lt;<span class="name">username</span>&gt;</span>/<span class="tag">&lt;<span class="name">repository</span>&gt;</span>:<span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 local 不存在 image，Docker 會從 repository pull image 下來再執行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Dodkcer Get Started&lt;/a&gt; 隨手記。&lt;/p&gt;
&lt;h2 id=&quot;Part-1-Orientation-and-setup&quot;&gt;&lt;a href=&quot;#Part-1-Or</summary>
      
    
    
    
    <category term="Get started with Docker" scheme="http://www.cjwind.idv.tw/categories/Get-started-with-Docker/"/>
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
</feed>
