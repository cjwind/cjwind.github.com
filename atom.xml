<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cjwind&#39;s note</title>
  
  <subtitle>要夠努力，但不要太努力</subtitle>
  <link href="http://www.cjwind.idv.tw/atom.xml" rel="self"/>
  
  <link href="http://www.cjwind.idv.tw/"/>
  <updated>2021-03-07T07:49:16.504Z</updated>
  <id>http://www.cjwind.idv.tw/</id>
  
  <author>
    <name>cjwind</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ch1 跑者成功的要素</title>
    <link href="http://www.cjwind.idv.tw/daniels-running-formula/ch1/"/>
    <id>http://www.cjwind.idv.tw/daniels-running-formula/ch1/</id>
    <published>2021-03-07T07:45:41.000Z</published>
    <updated>2021-03-07T07:49:16.504Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/daniels-running-formula/ch1-mindmap.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/daniels-running-formula/ch1-mindmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Running" scheme="http://www.cjwind.idv.tw/tags/Running/"/>
    
  </entry>
  
  <entry>
    <title>ch2 API Paradigms</title>
    <link href="http://www.cjwind.idv.tw/Designing-Web-APIs/Designing-Web-APIs-ch2/"/>
    <id>http://www.cjwind.idv.tw/Designing-Web-APIs/Designing-Web-APIs-ch2/</id>
    <published>2021-02-27T10:27:28.000Z</published>
    <updated>2021-02-27T10:28:46.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>An API paradigmdefines the interface exposing backend data of a service to otherapplications.</p></blockquote><h2 id="Request-Response-API"><a href="#Request-Response-API" class="headerlink" title="Request-Response API"></a>Request-Response API</h2><p>Request-Response API 通常透過 HTTP web server 來公開 interface。</p><p>這種 API 會定義一些 endpoints，client 對這些 endpoints 發出 HTTP request 來索取資料，server 則給予 response。response 通常是 JSON 或 XML 格式。</p><p>Request-Response API 有三種：</p><ul><li>REST</li><li>RPC</li><li>GraphQL</li></ul><h3 id="REST-Representational-State-Transfer"><a href="#REST-Representational-State-Transfer" class="headerlink" title="REST (Representational State Transfer)"></a>REST (Representational State Transfer)</h3><blockquote><p>REST is all about <em>resource</em>.</p></blockquote><p>resource 是可以在 web 上被 identify、named、addressed 或 handled 的 entity。</p><p>REST API 將資料當成 resource 來 expose 出去，並使用 standard HTTP method 表示 CRUD 的動作。</p><p>REST API 遵循的一般規則：</p><ul><li>resource 是 URL 的一部分，例如 <code>/users</code></li><li>每個 resource 通常有兩個 URL。一個表示 collection，例如 <code>/users</code>。一個表示特定元素，例如 <code>/users/U123</code>。</li><li>resource 使用名詞而非動詞，例如用 <code>/users/U123</code>，而不是 <code>/getUserInfo/U123</code>。</li><li>用 <code>GET</code>、<code>POST</code>、<code>UPDATE</code> 跟 <code>DELETE</code> 等 HTTP method 來告訴 server 要執行的動作。<ul><li>Create<ul><li>用 <code>POST</code> 建立新 resource</li></ul></li><li>Read<ul><li>用 <code>GET</code> 讀取 resource</li><li><code>GET</code> request 永遠不會改變 resource 的狀態，不會有 side effect</li><li><code>GET</code> method 有 read-only 的意思</li><li><code>GET</code> 是 idempotent</li></ul></li><li>Update<ul><li>用 <code>PUT</code> 來 replace resource。</li><li>用 <code>PATCH</code> 來對現有 resource 做部份 update。<a href="http://tools.ietf.org/html/rfc5789">RFC 5789</a></li></ul></li><li>Delete<ul><li>以 <code>DELETE</code> 來刪除現有 resource。</li></ul></li></ul></li><li>server 回傳標準的 HTTP response status code 來表示成功或失敗<ul><li>2XX 代表成功</li><li>3XX 代表 resource 已被移除</li><li>4XX 代表 client 端錯誤</li><li>5XX 代表 server 端錯誤</li></ul></li><li>REST API 可回傳 JSON 或 XML 格式</li></ul><h4 id="Showing-relationships"><a href="#Showing-relationships" class="headerlink" title="Showing relationships"></a>Showing relationships</h4><p>盡量用 subresource 表示只屬於其他 resource 的 resource，不要用 top-level resource 表示它，這樣可以讓使用 API 的 developer 知道它們之間的關係。</p><p>例如 Github 的 API：<code>POST /repos/:owner/:repo/issues</code> 是在某個人的某個 repository 底下建立一個 issue。</p><h4 id="非-CRUD-操作"><a href="#非-CRUD-操作" class="headerlink" title="非 CRUD 操作"></a>非 CRUD 操作</h4><p>有時候 REST API 需要表示非 CRUD 的操作，常見作法如下：</p><ul><li>以 resource 的部份欄位來表示動作（action）<ul><li>例如 Github 要把 repository archive 起來是用 entry <code>PATCH /repos/:owner/:repo</code> 然後 data body 是 <code>&#123;&quot;archived&quot;: true&#125;</code>。因為 <code>PATCH</code> entry 的 request  data body 是 resource 要被更新的欄位，所以才說是以「resource 的部份欄位」來表示動作。</li></ul></li><li>將操作視為 subresource<ul><li>例如 Github 的 lock issue 是 <code>PUT /repos/:owner/:repo/issues/:number/lock</code></li></ul></li><li>有些操作難以用 REST 模式，例如搜尋，這時候通常會在 API URL 直接使用操作的動詞。<ul><li>例如在 Github 中尋找符合 query 的檔案：<code>GET /search/code?q=:query:</code>。</li></ul></li></ul><h3 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h3><p>REST 跟 resource 有關，RPC 則跟動作（action）有關。</p><p>RPC 的 client 會在 server 上執行一段 code。client 通常會傳 method name 跟 argument 給 server，然後得到 JSON 或 XML。</p><p>RPC API 通常遵循兩個規則：</p><ul><li>endpoint 含有準備執行的 action 的名稱</li><li>API call 是用最適合的 HTTP verb 來執行：<code>GET</code> 是 read-only request，<code>POST</code> 則是其他。</li></ul><blockquote><p>當 API 公開的動作比 CRUD 封裝的還要細膩且複雜，或是存在與眼前的「資源」無關的 side effect 時，很適合使用 RPC。RPC style 的 API 也可以配合複雜的 resource model，或針對多種類型的 resource 執行的動作。</p></blockquote><p>RPC style 的 API 除了用 HTTP 外也可以用其他 protocol，包括 <a href="https://thrift.apache.org">Apache Thrift</a> 跟 <a href="https://grpc.io/docs/guides/index.html">gRPC</a>。</p><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p><a href="https://graphql.org">https://graphql.org</a></p><p>GraphQL 可以讓 client 端定義需要的 data structure，讓 server 以那個 structure 回傳資料。例如以下是送給 Github API 的 GraphQL query 及其 response：</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(<span class="name">login:</span> <span class="string">&quot;saurabhsahni&quot;</span>) &#123;</span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">        company</span><br><span class="line">        createdAt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>response：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;MDQ6VXNlcjY1MDIS&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Saurabh Sahni&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;company&quot;</span>: <span class="string">&quot;Slack&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;createdAt&quot;</span>: <span class="string">&quot;2009-03-19T21:00:06Z&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GraphQL 只需要一個 URL endpoint，而且不需要用不同的 HTTP verb 描述操作，只要在 JSON 內容中寫要做的動作就可以了。</p><h4 id="GraphQL-的優點"><a href="#GraphQL-的優點" class="headerlink" title="GraphQL 的優點"></a>GraphQL 的優點</h4><p>跟 REST 及 RPC 比起來，GraphQL 的優點：</p><ul><li>節省多次 round trip<ul><li>client 可以用 nested query 以一個 request 從多個 resource 取得資料</li><li>以 REST 來說，要取得多個 resource 資料可能需要很多個 request</li></ul></li><li>不需要 versioning<ul><li>在 GraphQL API 增加新的欄位跟 type 不會影響既有的 query</li><li>要 deprecate 一個欄位也很容易：可以用 log 分析 client 用了哪些欄位，在工具中隱藏某些欄位，並且在沒人用的時候移除它們。</li></ul></li><li>較小的 payload<ul><li>因為 client 可以明確指定要什麼資料，所以 payload 可以比較小。</li><li>REST 跟 RPC 常常回傳 client 永遠用不到的資料。</li></ul></li><li>Strongly typed<ul><li>GraphQL 是 strongly typed，它的 type checking 會確保 query 的語法是正確且有效的。</li></ul></li><li>Introspection<ul><li><a href="https://github.com/graphql/graphiql">GraphiQL</a> 這個瀏覽器 IDE 可以寫 GraphQL query 來試驗跟了解 GraphQL API <em>（就是可以直接玩 API 啦）</em></li></ul></li></ul><h4 id="GraphQL-的缺點"><a href="#GraphQL-的缺點" class="headerlink" title="GraphQL 的缺點"></a>GraphQL 的缺點</h4><p>對提供 GraphQL API 的提供者來說，GraphQL 增加了複雜性，server 需要做額外的工作來解析複雜的 query 跟驗證參數。最佳化 GraphQL query 的效能也很麻煩。</p><h3 id="REST-vs-RPC-vs-GraphQL"><a href="#REST-vs-RPC-vs-GraphQL" class="headerlink" title="REST vs RPC vs GraphQL"></a>REST vs RPC vs GraphQL</h3><img src="/images/designing-web-apis/ch2-1.jpg" class="" width="620"><img src="/images/designing-web-apis/ch2-2.jpg" class="" width="620"><h2 id="Event-Driven-API"><a href="#Event-Driven-API" class="headerlink" title="Event-Driven API"></a>Event-Driven API</h2><p>如果 service 的資料常常會改變，用 request-response API 的作法 response 很快會過時，這時候使用 API 的 developer 通常會以 polling 來確保得到最新的資料。但如果 polling 頻率太低，可能會在需要即時更新的狀況下無法即時更新 。而 polling 頻率太高則會浪費資源，因為大部分 request 都不會有新資料。</p><p>要即時分享 event 資料，有三種方式：WebHook、WebSocket 跟 HTTP Streaming。</p><h3 id="WebHook"><a href="#WebHook" class="headerlink" title="WebHook"></a>WebHook</h3><p><strong>WebHook 是個接收 HTTP POST（或 GET、PUT 或 DELETE）的 URL。</strong> 實作 WebHook 的 API provider 會在某些事情發生時 POST 一個訊息給使用者設置好的 URL，例如信用卡授權的 postback。</p><p>提供 WebHook 會引入的複雜性：</p><ul><li>Failures and retries：為了確保資訊成功 deliver，須建立發生錯誤時的 retry 機制。</li><li>Security：使用 WebHook 時，API 使用者要驗證從 WebHook 收到的資料，以確保資料是合法的。</li><li>Firewall：在防火牆後的 app 很難用 WebHook 收資料，得在防火牆上打洞。</li><li>Noise 雜訊：通常一個 WebHook call 都代表一個 event。如果有成千上萬個 event 在短時間內發生而且必須透過單一 WebHook 來傳送，可能會產生雜訊。</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>WebSocket is a protocol used to establish a two-way streaming communication channel over a single Transport Control Protocol (TCP) connection.</p></blockquote><p>WebSocket 這個 protocol 通常用在 web client 跟 server 間，有時也會被用來做 server 對 server 的通訊。WebSocket 可以在比較低的 overhead 的情況下開啟 full-duplex 通訊（server 跟 client 可以同時跟對方通訊）。</p><p>WebSocket 是運作在 port 80 或 443 上，所以不用在防火牆上另外開 port 來進行連線與通訊。而且使用 WebSocket 也不像 WebHook 得對 internet 打開一個 HTTP endpoint 來接收 event，相對來說比較安全。</p><p>WebSocket 適合快速、live 的 streaming 以及長時間（long-lived）的 connection。但不見得適合用在行動裝置或者網路不穩定的地方，因為 client 必須有能力維持 connection，connection 斷了 client 就得重新啟動它。</p><h3 id="HTTP-Streaming"><a href="#HTTP-Streaming" class="headerlink" title="HTTP Streaming"></a>HTTP Streaming</h3><p>在 request-response 形式的 HTTP API 裡，client 送出 request 後，會收到一包有限長度的 response。而使用 HTTP Streaming，server 可以透過 client 開啟的 long-lived connection 來持續推送新資料。</p><img src="/images/designing-web-apis/ch2-3.png" class="" width="620"><blockquote><p>To  transmit  data  over  a  persistent  connection  from  server  to  client, there  are  two  options.  The  first  option  is  for  the  server  to  set  the Transfer-Encoding header to chunked. This indicates to clients that data will be arriving in chunks of newline-delimited strings. For typ‐ical application developers, this is easy to parse.<br>Another  option  is  to  stream  data  via  server-sent  events  (SSE).  This option  is  great  for  clients  consuming  these  events  in  a  browser because they can use the standardized EventSource API.</p></blockquote><blockquote><p>HTTP  Streaming  is  easy  to  consume.  However,  one  of  the  issues with  it  is  related  to  buffering.  Clients  and  proxies  often  have  bufferlimits. They might not start rendering data to the application until a threshold is met. Also, if clients want to frequently change what kind of events they listen to, HTTP Streaming might not be ideal because it requires reconnections.</p></blockquote><h3 id="Event-Driven-API-的比較"><a href="#Event-Driven-API-的比較" class="headerlink" title="Event-Driven API 的比較"></a>Event-Driven API 的比較</h3><img src="/images/designing-web-apis/ch2-4.png" class="" width="620"><img src="/images/designing-web-apis/ch2-5.png" class="" width="620"><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>沒有一體適用的 API paradigm。每種 API paradigm 只適合特定類型的 use case，所以在實際狀況下有可能需要支援多種 paradigm。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;An API paradigmdefines the interface exposing backend data of a service to otherapplications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Requ</summary>
      
    
    
    
    <category term="Designing Web Apis" scheme="http://www.cjwind.idv.tw/categories/Designing-Web-Apis/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>《原子習慣》</title>
    <link href="http://www.cjwind.idv.tw/Atomic-Habits/"/>
    <id>http://www.cjwind.idv.tw/Atomic-Habits/</id>
    <published>2021-02-16T10:01:51.000Z</published>
    <updated>2021-02-26T01:18:35.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="/images/atomic_habits_mindmap1.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/atomic_habits_mindmap1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
  </entry>
  
  <entry>
    <title>Docker command snippet</title>
    <link href="http://www.cjwind.idv.tw/Docker-command-snippet/"/>
    <id>http://www.cjwind.idv.tw/Docker-command-snippet/</id>
    <published>2021-02-09T12:02:56.000Z</published>
    <updated>2021-02-09T12:19:00.121Z</updated>
    
    <content type="html"><![CDATA[<p>老是失憶……</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跑起一個 ubuntu container 並且用 foreground 模式進入 bash</span></span><br><span class="line"><span class="variable">$ </span>sudo docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>sudo docker run -d -p [HOST_PORT]<span class="symbol">:</span>[CONTAINER_PORT] --name [CONTAINER_NAME] [IMAGE_NAME]<span class="symbol">:</span>[version]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止並移除 container</span></span><br><span class="line"><span class="variable">$ </span>sudo docker rm --force [CONTAINER]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 local 有的 image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Docker Hub 搜尋 image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker search [KEYWORD]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在有 Dockerfile 的資料夾 build Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker build --tag [NAME]<span class="symbol">:</span>[TAG] .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker rmi [IMAGE]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Login to a Docker registry</span></span><br><span class="line"><span class="comment"># 如果是 private registry 就要 login 才能 push</span></span><br><span class="line"><span class="variable">$ </span>sudo docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># Push Docker image</span></span><br><span class="line"><span class="variable">$ </span>sudo docker push [IMAGE_NAME]<span class="symbol">:</span>[TAG]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;老是失憶……&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 跑起一個 ubuntu conta</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Readmoo API Go Package</title>
    <link href="http://www.cjwind.idv.tw/Readmoo-API/"/>
    <id>http://www.cjwind.idv.tw/Readmoo-API/</id>
    <published>2021-02-09T08:51:05.000Z</published>
    <updated>2021-02-09T09:30:46.047Z</updated>
    
    <content type="html"><![CDATA[<p>用 Go 寫了個可以讀 Readmoo 的閱讀記錄跟劃線的 package。</p><p>可以從閱讀記錄拿到基本的書籍資料跟劃線。</p><p>細節見 <a href="https://github.com/cjwind/readmoo">Github</a>。</p><p><em>應該要把拿 token 弄得簡單點，現在很手動…</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用 Go 寫了個可以讀 Readmoo 的閱讀記錄跟劃線的 package。&lt;/p&gt;
&lt;p&gt;可以從閱讀記錄拿到基本的書籍資料跟劃線。&lt;/p&gt;
&lt;p&gt;細節見 &lt;a href=&quot;https://github.com/cjwind/readmoo&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Project" scheme="http://www.cjwind.idv.tw/tags/Project/"/>
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PhpStorm 快捷鍵</title>
    <link href="http://www.cjwind.idv.tw/PhpStorm-shortcut/"/>
    <id>http://www.cjwind.idv.tw/PhpStorm-shortcut/</id>
    <published>2021-02-05T15:57:41.000Z</published>
    <updated>2021-02-05T15:57:41.634Z</updated>
    
    <content type="html"><![CDATA[<p>我的 keymap 是 Sublime + Jetbrains 部份按鍵 + 自己設再配 vim 的大雜燴</p><ul><li><code>ctrl + shift + p</code>：執行動作（action）</li><li><code>ctrl + p</code>：找檔案</li><li><code>ctrl + r</code>：檔案中找 symbol</li><li><code>ctrl + alt + shift + t</code>：refactor 選單</li><li><code>alt + enter</code>：各種神奇功能(?)</li><li><code>alt + insert</code>：加入各種 code</li><li><code>shift + f6</code>：rename</li><li><code>alt + 1</code>：project browse window</li><li><code>alt + 3</code>：find window</li><li><code>alt + 4</code>：run window</li><li><code>alt + 9</code>：git window</li></ul><p>TBC…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的 keymap 是 Sublime + Jetbrains 部份按鍵 + 自己設再配 vim 的大雜燴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl + shift + p&lt;/code&gt;：執行動作（action）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl + p&lt;/co</summary>
      
    
    
    
    
    <category term="PhpStorm" scheme="http://www.cjwind.idv.tw/tags/PhpStorm/"/>
    
  </entry>
  
  <entry>
    <title>《跑者都該懂的跑步關鍵數據》跑步技術</title>
    <link href="http://www.cjwind.idv.tw/You-should-know-these-running-data/"/>
    <id>http://www.cjwind.idv.tw/You-should-know-these-running-data/</id>
    <published>2021-02-04T15:23:08.000Z</published>
    <updated>2021-02-26T01:18:35.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mindmap-v1"><a href="#Mindmap-v1" class="headerlink" title="Mindmap v1"></a>Mindmap v1</h2><p><img src="/images/20210204_%E3%80%8A%E8%B7%91%E8%80%85%E9%83%BD%E8%A9%B2%E6%87%82%E7%9A%84%E9%97%9C%E9%8D%B5%E6%95%B8%E6%93%9A%E3%80%8B%E8%B7%91%E6%AD%A5%E6%8A%80%E8%A1%93_v1.png" alt=""></p><h2 id="Mindmap-v2"><a href="#Mindmap-v2" class="headerlink" title="Mindmap v2"></a>Mindmap v2</h2><p><img src="/images/20210209_%E3%80%8A%E8%B7%91%E8%80%85%E9%83%BD%E8%A9%B2%E6%87%82%E7%9A%84%E9%97%9C%E9%8D%B5%E6%95%B8%E6%93%9A%E3%80%8B%E8%B7%91%E6%AD%A5%E6%8A%80%E8%A1%93_v2.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mindmap-v1&quot;&gt;&lt;a href=&quot;#Mindmap-v1&quot; class=&quot;headerlink&quot; title=&quot;Mindmap v1&quot;&gt;&lt;/a&gt;Mindmap v1&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/20210204_%E3%80%8A%E</summary>
      
    
    
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Mindmap" scheme="http://www.cjwind.idv.tw/tags/Mindmap/"/>
    
    <category term="慢跑" scheme="http://www.cjwind.idv.tw/tags/%E6%85%A2%E8%B7%91/"/>
    
  </entry>
  
  <entry>
    <title>Go Module</title>
    <link href="http://www.cjwind.idv.tw/Golang/Go-Module/"/>
    <id>http://www.cjwind.idv.tw/Golang/Go-Module/</id>
    <published>2021-01-24T09:34:34.000Z</published>
    <updated>2021-01-24T09:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 從 1.13 開始支援 Go Module，可以在 <code>GOPATH</code> 以外的地方建立 go project 並進行套件管理。<em>一直覺得 source code 只能放在 <code>GOPATH</code> 裡超阿雜…</em></p><h2 id="建立-project"><a href="#建立-project" class="headerlink" title="建立 project"></a>建立 project</h2><p>在 <code>GOPATH</code> 以外的地方建立一個 directory，並且在其中執行 <code>go mod init</code>：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ mkdir <span class="keyword">project</span></span><br><span class="line">$ cd <span class="keyword">project</span></span><br><span class="line">$ go mod init github.com<span class="regexp">/cjwind/</span><span class="keyword">project</span></span><br></pre></td></tr></table></figure><p>會產生 <code>go.mod</code> 檔案，它會記錄 Go module 與使用的 Go 版本：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">module github.com<span class="regexp">/cjwind/</span><span class="keyword">project</span></span><br><span class="line"></span><br><span class="line">go <span class="number">1.15</span></span><br></pre></td></tr></table></figure><p>接下來在這個 directory 裡進行開發跟 build 就都一樣，重點是現在 source code 不用非得放在 <code>GOPATH</code> 裡啦～</p><h2 id="套件管理"><a href="#套件管理" class="headerlink" title="套件管理"></a>套件管理</h2><p>用 <code>go get</code> 安裝 package 後，會發現在 <code>go.mod</code> 多了一行 <code>require [package] [version]</code>，就表示目前使用的 package 及其 version。</p><p>另外可能會出現 <code>require [package] [version] // indirect</code>，這表示是我們使用的 package 所需要的 package。</p><p>也可以用 <code>go get [package]@[version]</code> 來指定特定的 package version。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://blog.golang.org/using-go-modules">Using Go Modules</a></li><li><a href="https://golang.org/ref/mod">Go Modules Reference</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 從 1.13 開始支援 Go Module，可以在 &lt;code&gt;GOPATH&lt;/code&gt; 以外的地方建立 go project 並進行套件管理。&lt;em&gt;一直覺得 source code 只能放在 &lt;code&gt;GOPATH&lt;/code&gt; 裡超阿雜…&lt;/em&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="http://www.cjwind.idv.tw/Dockerfile/"/>
    <id>http://www.cjwind.idv.tw/Dockerfile/</id>
    <published>2020-11-21T14:49:58.000Z</published>
    <updated>2020-11-21T14:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code> 如果 source 是 directory，會 copy directory 的內容，但是 directory 本身不會 copy。</p><p>假設有個資料夾叫 <code>css/</code>，底下有兩個 file <code>foo.css</code> 跟 <code>bar.css</code>。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./css /workspace/</span></span><br></pre></td></tr></table></figure><p>這樣在 container 裡會變成 <code>/workspace/</code> 底下有 <code>foo.css</code> 跟 <code>bar.css</code>，而不是 <code>/workspace/css/</code> 底下有 <code>foo.css</code> 跟 <code>bar.css</code>。想要是 <code>/workspace/css/</code> 底下有兩個 file 得這樣寫：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./css /workspace/css</span></span><br></pre></td></tr></table></figure><p>Ref：<a href="https://docs.docker.com/engine/reference/builder/#copy">https://docs.docker.com/engine/reference/builder/#copy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;COPY&quot;&gt;&lt;a href=&quot;#COPY&quot; class=&quot;headerlink&quot; title=&quot;COPY&quot;&gt;&lt;/a&gt;COPY&lt;/h2&gt;&lt;p&gt;&lt;code&gt;COPY&lt;/code&gt; 如果 source 是 directory，會 copy directory 的內容，但</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://www.cjwind.idv.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go json and embedded struct</title>
    <link href="http://www.cjwind.idv.tw/Golang/Go-json-and-embedded-struct/"/>
    <id>http://www.cjwind.idv.tw/Golang/Go-json-and-embedded-struct/</id>
    <published>2020-11-15T14:00:46.000Z</published>
    <updated>2020-11-15T14:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 embedded struct 做 json 的 marshal 跟 unmarshal 時，json 欄位會省略 struct embedded 欄位的中間名，以比較簡潔的形式呈現。如果 struct 有寫出欄位名稱，json 欄位就會多那一層。</p><h2 id="使用-embedded-struct"><a href="#使用-embedded-struct" class="headerlink" title="使用 embedded struct"></a>使用 embedded struct</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Serving <span class="keyword">struct</span> &#123;</span><br><span class="line">    Amount <span class="keyword">float64</span></span><br><span class="line">    Unit   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Serving    <span class="comment">// embedded struct</span></span><br><span class="line">    NutritionInfo</span><br><span class="line">    Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>marshal 結果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Banana&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Amount&quot;</span>:<span class="number">100</span>,</span><br><span class="line">  <span class="attr">&quot;Unit&quot;</span>:<span class="string">&quot;g&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Calorie&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Carb&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Fat&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Protein&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不使用-embedded-struct"><a href="#不使用-embedded-struct" class="headerlink" title="不使用 embedded struct"></a>不使用 embedded struct</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Serving Serving    <span class="comment">// not embedded struct</span></span><br><span class="line">    NutritionInfo</span><br><span class="line">    Comment <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>marshal 結果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Banana&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Serving&quot;</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;Amount&quot;</span>:<span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;Unit&quot;</span>:<span class="string">&quot;g&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Calorie&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Carb&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Fat&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Protein&quot;</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用 embeded struct 就會有一層 <code>Serving</code>，用 embedded struct 就會省略 <code>Serving</code> 這層。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 embedded struct 做 json 的 marshal 跟 unmarshal 時，json 欄位會省略 struct embedded 欄位的中間名，以比較簡潔的形式呈現。如果 struct 有寫出欄位名稱，json 欄位就會多那一層。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Git submodule</title>
    <link href="http://www.cjwind.idv.tw/Git-submodule/"/>
    <id>http://www.cjwind.idv.tw/Git-submodule/</id>
    <published>2020-10-08T15:12:57.000Z</published>
    <updated>2020-10-08T15:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>submodule 是在 git repos 中使用別的 repos 的方式之一。</p><p>git 的 submodule 是記錄一個指到別人 repo 某個 commit 的指標。對主 repo 來說，記錄的只是一個 submodule commit hash。</p><p>切到 submodule 的目錄時做 git 操作會是在操作另一個 repo。</p><h2 id="加入-submodule"><a href="#加入-submodule" class="headerlink" title="加入 submodule"></a>加入 submodule</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule add &lt;repo path&gt;</span></span><br></pre></td></tr></table></figure><h2 id="clone-含有-submodule-的-repos"><a href="#clone-含有-submodule-的-repos" class="headerlink" title="clone 含有 submodule 的 repos"></a>clone 含有 submodule 的 repos</h2><p>clone 含有 submodule 的 repos 後，submodule 的目錄會是空的，要做以下動作來初始化：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update</span></span><br></pre></td></tr></table></figure><p><code>git submodule update</code> 會讓 submodule 的內容回到記錄的 commit。</p><h2 id="更新-submodule"><a href="#更新-submodule" class="headerlink" title="更新 submodule"></a>更新 submodule</h2><p>submodule 的 repo 更新或者想用不同版本（commit）的 submodule 時，要做以下操作：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> submodule_dir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git a submodule_dir<span class="comment"># 更新主 repo 記錄的 submodule commit hash</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ci</span></span><br></pre></td></tr></table></figure><p>概念是把 submodule 的 repo 更新或者 checkout 到想要的 commit，再在主 repo 更新記錄的 submodule commit hash。</p><h2 id="移除-submodule"><a href="#移除-submodule" class="headerlink" title="移除 submodule"></a>移除 submodule</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm -rf submodule_dir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim .git/config<span class="comment"># 移掉 submodule 相關設定</span></span></span><br></pre></td></tr></table></figure><h2 id="gitmodules"><a href="#gitmodules" class="headerlink" title=".gitmodules"></a>.gitmodules</h2><p>檔案 <code>.gitmodules</code> 會記錄有哪些 submodule。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;submodule 是在 git repos 中使用別的 repos 的方式之一。&lt;/p&gt;
&lt;p&gt;git 的 submodule 是記錄一個指到別人 repo 某個 commit 的指標。對主 repo 來說，記錄的只是一個 submodule commit hash。&lt;/</summary>
      
    
    
    
    
    <category term="Git" scheme="http://www.cjwind.idv.tw/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Go init() function</title>
    <link href="http://www.cjwind.idv.tw/Golang/Golang-init-func/"/>
    <id>http://www.cjwind.idv.tw/Golang/Golang-init-func/</id>
    <published>2020-08-29T09:48:15.000Z</published>
    <updated>2021-02-26T14:42:35.572Z</updated>
    
    <content type="html"><![CDATA[<p>任何檔案可以擁有任意數量的 <code>init()</code> function：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init()</code> 會在程式啟動時自動以宣告的順序執行，但不能被 call 或參考。</p><p>假設有以下兩個 go 檔案：</p><figure class="highlight go"><figcaption><span>foo.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;foo.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go second init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>go run</code> 以不同的順序指定 source file 會有不同結果：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">go</span> run foo.<span class="built_in">go</span> main.<span class="built_in">go</span></span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">go</span> run main.<span class="built_in">go</span> foo.<span class="built_in">go</span></span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line"></span><br><span class="line"># 不指定 file</span><br><span class="line">$ <span class="built_in">go</span> run .</span><br><span class="line">foo.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">first</span> init</span><br><span class="line">main.<span class="built_in">go</span> <span class="built_in">second</span> init</span><br></pre></td></tr></table></figure><p>不指定 file 的話 <code>go</code> 會將 file 以其名稱排序。</p><p>如果嘗試直接 call <code>init()</code> 則會 compile error：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main.go first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    init()  <span class="comment">// compile error: undefined: init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任何檔案可以擁有任意數量的 &lt;code&gt;init()&lt;/code&gt; function：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="Go" scheme="http://www.cjwind.idv.tw/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>ch10 I Can&#39;t Run This Method in a Test Harness</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch10-I-Can-t-Run-This-Method-in-a-Test-Harness/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch10-I-Can-t-Run-This-Method-in-a-Test-Harness/</id>
    <published>2020-08-29T07:35:09.000Z</published>
    <updated>2020-09-19T05:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>要為一段 code 寫測試，首先要在測試中建立它所屬的 class 的 instance，接著為要修改的 method 寫測試。這章要解決的是「難以在測試中執行要測試的 method」的情境。為一個 method 寫測試可能會遇到的問題：</p><ul><li>無法在測試中 access 那個 method，例如它可能是 private 的或是有其他存取限制。</li><li>很難建立所需參數，導致很難 call method，例如參數是一包 XML。</li><li>要測試的 method 可能產生糟糕的 side effect，例如修改 DB、發射飛彈等等，所以無法在測試中執行它。</li><li>需要透過該 method 使用的 object 進行 sense，才能知道這個 method 做了什麼事。</li></ul><h1 id="The-Case-of-the-Hidden-Method"><a href="#The-Case-of-the-Hidden-Method" class="headerlink" title="The Case of the Hidden Method"></a>The Case of the Hidden Method</h1><p>假設我們要修改的是一個 private method，想要測試它，該怎麼辦呢？</p><p>首先，能透過 public method 來測試它嗎？如果可以，就這麼幹吧～用 public method 去測試，就是按照程式中 private method 如何被使用的方式去測試它。如果有天要把 private method 改成 public，把它變成 public 的人應該寫一系列的測試說明這個 method 的用途以及 caller 該如何使用它。</p><p>這邊有提到一點 method 設計實作上的小概念：</p><blockquote><p>雖然 general 的 method 對 caller 來說蠻有用的，但每個 method 的功能應該剛好可以滿足 caller 並且易於理解與修改。</p></blockquote><p>有時候呢，我們就是想直接為 private method 寫測試（任性），可能是因為我們想用測試來知道如何使用 private method，或者用 public method 來測試它實在太難太痛苦啦～</p><p>例如一個擁有商業邏輯並且會 call third-party API 的 class 做的事情是：call API 取得一包 XML 資料，parse XML 得到商業邏輯需要的資料，再做商業邏輯上的計算或操作。我們想知道 parse XML 的 private method 是否正確，但它埋在整個流程裡，而用 public method 做整個的 call API、parsing、商業邏輯的測試難以只測試到 parse XML 的部份。</p><p>所以，想為 private method 寫測試時該怎麼辦呢？</p><blockquote><p>如果需要測試一個 private method，就該把它設成 public。</p></blockquote><p>看到書上這句話我蠻驚恐的，想著：「等等等，不是吧？就這樣直接把 private method 變成 public 好嗎？這不會在 class 上開出看起來突兀或者不知如何使用的 method 嗎？」</p><blockquote><p>如果不方便將其設為 public，大多數情況下意味著我們的 class 做太多事了，應該進行調整。</p></blockquote><p>喔～原來是這樣～這倒是真的～像上面那個例子，一個 class 既 call third-party API 又 parse XML 又做商業邏輯，太多事情了。</p><p>如果我們想測試一個 private method，首先看它是不是個適合在這個 class 當作 public 的 method？如果是，直接改成 public。否則看看是不是這個 class 做太多事了，有些事可以交由另一個 class 處理。例如我們把 parse XML 有關的 method 放到另一個 parser class，這些 method 到了新 class 會變成 public，原本的 class 就能 new 一個 parser 出來做事。</p><blockquote><p>好的設計應當是可測試的，不具可測試性的設計是糟糕的。</p></blockquote><p>如果我們遇到上面這樣的狀況，想拆解 class、將職責分開，卻沒有多少現成測試呢？假設我們想拆解這個包山包海的 class，但它本身卻沒有什麼測試，而 refactor 應當要有測試保護，雞生蛋蛋生雞的問題出現啦～</p><p>又或許，我們正在開發週期的後期，軟體已經接近 deploy，我們沒有多少時間去做拆解的 refactor，而且沒有測試又讓 refactor 的風險大幅提昇。儘管 refactor 可以改善程式結構、有好處，但需要考慮目前處於開發週期的哪個階段、時間多寡與風險高低，才能決定要不要 refactor 以及 refactor 到什麼程度。</p><p>時間不夠或風險太高的時，我們無法拆解 class。退而求其次，至少幫我們要修改的 private method 加上測試，讓這個 class 開始有測試保護也是好的。</p><p>想為 private method 加上測試，表示要能在測試中直接 call 到這個 method，要怎麼做呢？</p><p>又用到 Extract and Override 了～<em>這招也太萬用…</em></p><p>假設我們有個與機票搜尋、訂購有關的 class：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params"><span class="variable">$searchParams</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call third party api and get response as xml</span></span><br><span class="line">    <span class="variable">$searchResults</span> = <span class="keyword">$this</span>-&gt;parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">    <span class="comment">// other impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params"><span class="variable">$xml</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">booking</span>(<span class="params"><span class="variable">$bookingParams</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>search()</code> 裡先用 http client 向 third party API 送 request 並收 response，response 是一包 XML，我們想 parse 出其中需要的資料而 call <code>parseSearchResponse()</code>。因為 XML 相當複雜，我們希望能單獨確認 parsing 結果是否正確。</p><p>這個 class 除了 search、booking、parse 各種 XML 之外還會做許多事情，它的職責太多了，如果我們現在沒有時間去拆解它，卻想測試 <code>parseSearchResponse()</code> 的結果該怎麼做？</p><p>首先將 <code>parseSearchResponse()</code> 從 <code>private</code> 變成 <code>protected</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params"><span class="variable">$searchParams</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// call third party api and get response as xml</span></span><br><span class="line">    <span class="variable">$searchResults</span> = <span class="keyword">$this</span>-&gt;parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">    <span class="comment">// other impl.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 變成 protected</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params"><span class="variable">$xml</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// impl.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著在測試中繼承它：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlightForTest</span> <span class="keyword">extends</span> <span class="title">Flight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parseSearchResponse</span>(<span class="params"><span class="variable">$xml</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parent</span>::parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就能在測試 call 到 <code>parseSearchResponse()</code> 進行測試了：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlightTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testParseSearchResponse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$target</span> = <span class="keyword">new</span> FlightForTest();</span><br><span class="line">    <span class="variable">$xml</span> = <span class="string">&#x27;blabla&#x27;</span>;</span><br><span class="line">    <span class="variable">$ret</span> = <span class="variable">$target</span>-&gt;parseSearchResponse(<span class="variable">$xml</span>);</span><br><span class="line">    <span class="comment">// assertions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這麼做雖然沒有立即改善 <code>Flight</code> 做太多事的問題，但至少幫修改的地方加上測試，確保目前的修改是正確的。並且為將來拆解 class 的 refactor 鋪路――因為加了些測試而減少之後 refactor 所需的 effort 跟時間，使之後 refactor 成為可能。</p><h1 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h1><ul><li><a href="https://dotblogs.com.tw/hatelove/2012/07/19/why-you-should-not-write-unit-test-with-private-and-protected-method">[測試]單元測試：是否針對非 public method 進行測試？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要為一段 code 寫測試，首先要在測試中建立它所屬的 class 的 instance，接著為要修改的 method 寫測試。這章要解決的是「難以在測試中執行要測試的 method」的情境。為一個 method 寫測試可能會遇到的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無法在測</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Unit Test" scheme="http://www.cjwind.idv.tw/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>安裝 mariadb 並設定 root password</title>
    <link href="http://www.cjwind.idv.tw/Install-mariadb-and-setup-root-password/"/>
    <id>http://www.cjwind.idv.tw/Install-mariadb-and-setup-root-password/</id>
    <published>2020-08-16T09:57:52.000Z</published>
    <updated>2020-08-16T10:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Debian，先安裝：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install mariadb-server</span></span><br></pre></td></tr></table></figure><p>裝完做些跟安全有關的設定跟 root password：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mysql_secure_installation</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Debian，先安裝：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="DB" scheme="http://www.cjwind.idv.tw/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>ch5 Tools</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch5-Tools/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch5-Tools/</id>
    <published>2020-08-13T01:19:58.000Z</published>
    <updated>2020-09-19T05:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul><li>自動化重構工具<ul><li>像 JetBrains、Visual Studio 等 IDE 的 refactor 功能。</li><li>在工具夠好的情況下，可以在沒有為 code 寫測試的情況下用工具進行自動化 refactor。但有時工具可能有問題，refactor 卻會修改到程式行為，所以使用工具進行 refactor 前，如果能先寫測試還是比較好的。</li><li>要注意工具在 refactor 時會跟不會進行哪些檢查<ul><li>例如 extract method，如果將新 method 命名為已存在 method 的名字，工具會不會顯示錯誤？</li></ul></li></ul></li><li>Unit Test 工具<ul><li>xUnit framework<br>  這類型 framework 執行測試大致的作法：找到 test class 裡所有 test method（依據語言不同有不同作法，有些語言可以用 reflection），為每個 test method 產生一個單獨的 object，該 object 的任務是去執行那個 test method。利用不同 object 隔離 test case，讓 test case 不會互相影響。</li></ul></li><li>一般測試控制工具<ul><li>FIT (Framework for Integration Test）</li><li>Fitnesse</li><li>Selenium</li><li><em>……等等其他</em></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;自動化重構工具&lt;ul&gt;
&lt;li&gt;像 JetBrains、Visual Studio 等 </summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Unit Test" scheme="http://www.cjwind.idv.tw/tags/Unit-Test/"/>
    
    <category term="Refactor" scheme="http://www.cjwind.idv.tw/tags/Refactor/"/>
    
  </entry>
  
  <entry>
    <title>ch4 The Seam Model</title>
    <link href="http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch4-The-Seam-Model/"/>
    <id>http://www.cjwind.idv.tw/Working-Effectively-with-Legacy-Code/ch4-The-Seam-Model/</id>
    <published>2020-08-11T01:11:13.000Z</published>
    <updated>2020-09-19T05:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Seam-amp-Enabling-Point"><a href="#Seam-amp-Enabling-Point" class="headerlink" title="Seam &amp; Enabling Point"></a>Seam &amp; Enabling Point</h1><p>seam（接縫）是指程式中一些特殊的點，在這些點上你不需要修改它本身就可以變動程式行為。</p><p>例如某段程式 call 了一個 function 來計算商品價格，現在想改變計算價格的 strategy。想在不改變 call 計價 function 的情況下，改變計價結果（程式行為）。</p><p>又例如程式 call 到牽連龐大子系統的 function，我們希望在 test 中避免執行到那些複雜的 code（不然很難測或無法測），又要在 prodcution code 裡照常執行到。如果這段 code 有 seam，便能在不改動到原本 call function 的情況下，換掉該 function 的行為來避免在 test 中碰到子系統。</p><p>每個 seam 都有一個 enabling point，在這裡你可以決定使用哪種行為。</p><p>seam 是可以讓你改變程式行為的「縫隙」，enabling point 則是決定那個 seam 要是什麼行為。在 enabling point 給不同的值，可以讓 seam 有不同的行為。例如物件 seam，物件 method 的參數列表是 enabling point，因為我們可以傳入不同的物件來改變程式行為。</p><p>為一團亂的 code 測試時，最好別去修改它本身，盡可能透過 seam 去解開 dependency 來測試。</p><h1 id="Seam-Types"><a href="#Seam-Types" class="headerlink" title="Seam Types"></a>Seam Types</h1><p>seam 有很多種類型。不同的語言，可以使用的類型也不同。一個語言從程式碼轉換到 machine code 的各個階段，擁有不同種類的 seam。</p><ul><li>preprocess 時期 seam<ul><li>在 C/C++ 裡可以用 macro 直接把字換掉來達到改變行為，例如直接把有 dependency 的 function call 用 <code>#define</code> 在 <code>#ifdef TESTING</code> 時換成空的 function。</li><li>enabling point 是 <code>#define TESTING</code></li></ul></li><li>link 時期 seam：在將多個 object file link 起來時的 seam<ul><li>dynamic link：直接換掉 dynamic link 要去找的 library 或 object file。</li><li>static link：透過 build script（像 Makefile），在測試環境去 link 抽換的 object file 而非原本 production code 的 object file。</li><li>enabling point 通常在 build 或 deploy script 裡，因為這時候才決定 link 誰。</li></ul></li><li>object seam<ul><li>一般用 interface、polymorphism 來做 dependency injection，以及 extract and override。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Seam-amp-Enabling-Point&quot;&gt;&lt;a href=&quot;#Seam-amp-Enabling-Point&quot; class=&quot;headerlink&quot; title=&quot;Seam &amp;amp; Enabling Point&quot;&gt;&lt;/a&gt;Seam &amp;amp; Enab</summary>
      
    
    
    
    <category term="Working Effectively with Legacy Code" scheme="http://www.cjwind.idv.tw/categories/Working-Effectively-with-Legacy-Code/"/>
    
    
    <category term="Reading" scheme="http://www.cjwind.idv.tw/tags/Reading/"/>
    
    <category term="Unit Test" scheme="http://www.cjwind.idv.tw/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Debian 10 Desktop 中文輸入</title>
    <link href="http://www.cjwind.idv.tw/Debian-10-Desktop-Chinese/"/>
    <id>http://www.cjwind.idv.tw/Debian-10-Desktop-Chinese/</id>
    <published>2020-08-09T06:41:36.000Z</published>
    <updated>2020-08-09T07:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>先安裝 ibus：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install ibus ibus-chewing</span><br></pre></td></tr></table></figure><p>在 <code>~/.bashrc</code>  加入：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GTK_IM_MODULE</span>=ibus</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">XMODIFIERS</span>=@im=ibus</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">QT_IM_MODULE</span>=ibus</span><br></pre></td></tr></table></figure><p>寫個 shell script：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ibus-daemon -d -x</span><br></pre></td></tr></table></figure><p>在 KDE Setting 的 Autostart 設定啟動時執行 shell script 來啟動 ibus</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先安裝 ibus：&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-&lt;span class=&quot;builtin-name</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://www.cjwind.idv.tw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git diff &amp; patch</title>
    <link href="http://www.cjwind.idv.tw/Git-diff-and-patch/"/>
    <id>http://www.cjwind.idv.tw/Git-diff-and-patch/</id>
    <published>2020-07-05T06:35:44.000Z</published>
    <updated>2020-08-09T03:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>用 Git diff 生 patch file</p><p><code>$ git diff [file] &gt; [path_file]</code></p><p>上 patch</p><p><code>$ patch -p1 &lt; [path_file]</code></p><ul><li>加 <code>-d [dir path]</code> 可以切換 directory</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://blog.longwin.com.tw/2013/08/linux-diff-patch-learn-note-2013/">https://blog.longwin.com.tw/2013/08/linux-diff-patch-learn-note-2013/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用 Git diff 生 patch file&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git diff [file] &amp;gt; [path_file]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上 patch&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ patch -p1 &amp;lt; [path_file]&lt;/</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://www.cjwind.idv.tw/tags/Linux/"/>
    
    <category term="Git" scheme="http://www.cjwind.idv.tw/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Day 4 C 語言與畫面顯示的練習</title>
    <link href="http://www.cjwind.idv.tw/30dayos/day4/"/>
    <id>http://www.cjwind.idv.tw/30dayos/day4/</id>
    <published>2020-05-08T13:42:52.000Z</published>
    <updated>2020-08-09T03:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>這天很多在介紹 C，尤其是 pointer，作者用組語的角度去看 C，很有趣。這邊只寫些簡單的筆記。</p><p>組語跟 C 一起使用時，只有 <code>EAX</code>、<code>ECX</code>、<code>EDX</code> 三個 register 可以使用，其他 register 只能 read 不能 write，因為它們存著 C 語言程式的相關資料。</p><p>C 語言中，普通數值跟表示 memory address 的數值被當作兩種不同的東西。</p><p>根據 C 語言規定，組語執行 <code>RET</code> 指令時， <code>EAX</code> 中的值就被看作是 function return value。</p><h2 id="調色盤設定顏色"><a href="#調色盤設定顏色" class="headerlink" title="調色盤設定顏色"></a>調色盤設定顏色</h2><p>在 8 bit 彩色模式下，顏色以 8 個 bit 表示，也就是 0~255。</p><p>每個數字表示什麼顏色，是由 developer 來決定的，不像 RGB 的 <code>#ffffff</code> 固定代表某個顏色。使用 0~255 表示顏色前，developer 要先幫這些數字指定好對應的顏色，例如 25 對應 <code>#ffffff</code> 等等。這種方式稱為「調色盤」。</p><p>設定調色盤的步驟如下：</p><ol><li>先 block interrupt</li><li>依據設定調色盤的方式，對 IO device 的某些 port 寫入資料</li><li>恢復對 interrupt 的處理</li></ol><h3 id="向-IO-Device-read-write"><a href="#向-IO-Device-read-write" class="headerlink" title="向 IO Device read/write"></a>向 IO Device read/write</h3><p>先來看怎麼對 IO device 讀寫。</p><p>CPU 與 IO device 相連，CPU 要能控制 IO device 當然有向 device 發送訊號與從 device 接收訊號的指令。</p><p>向 device 發送訊號的指令是 <code>OUT</code>，反之從 device 接收訊號的指令是 <code>IN</code>。就像 memory 用 memory address 區分不同位置，device 以 device port 區分不同 device。組語實作從 device read 與 write 到 device 的 function 們：</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; read 8 bit</span></span><br><span class="line"><span class="symbol">_io_in8:</span><span class="comment">; int io_in8(int port);</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EDX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]<span class="comment">; port (port number 只有 16 bit)</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EAX</span>,<span class="number">0</span>           <span class="comment">; 把 return value 清成 0</span></span><br><span class="line">        <span class="keyword">IN</span><span class="built_in">AL</span>,<span class="built_in">DX</span>           <span class="comment">; read 8 bit (AL)</span></span><br><span class="line">        <span class="keyword">RET</span>                             <span class="comment">; EAX 的值是 return value</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_io_in16:</span><span class="comment">; int io_in16(int port);</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EDX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]<span class="comment">; port</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EAX</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">IN</span><span class="built_in">AX</span>,<span class="built_in">DX</span>           <span class="comment">; read 16 bit (AX)</span></span><br><span class="line">        <span class="keyword">RET</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_io_in32:</span><span class="comment">; int io_in32(int port);</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EDX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]<span class="comment">; port</span></span><br><span class="line">        <span class="keyword">IN</span><span class="built_in">EAX</span>,<span class="built_in">DX</span>          <span class="comment">; read 32 bit (EAX)</span></span><br><span class="line">        <span class="keyword">RET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; write 8 bit</span></span><br><span class="line"><span class="symbol">_io_out8:</span><span class="comment">; void io_out8(int port, int data);</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EDX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]<span class="comment">; port</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">AL</span>,[<span class="built_in">ESP</span>+<span class="number">8</span>]<span class="comment">; data</span></span><br><span class="line">        <span class="keyword">OUT</span><span class="built_in">DX</span>,<span class="built_in">AL</span></span><br><span class="line">        <span class="keyword">RET</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_io_out16:</span><span class="comment">; void io_out16(int port, int data);</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EDX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]<span class="comment">; port</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EAX</span>,[<span class="built_in">ESP</span>+<span class="number">8</span>]<span class="comment">; data</span></span><br><span class="line">        <span class="keyword">OUT</span><span class="built_in">DX</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">RET</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_io_out32:</span><span class="comment">; void io_out32(int port, int data);</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EDX</span>,[<span class="built_in">ESP</span>+<span class="number">4</span>]<span class="comment">; port</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">EAX</span>,[<span class="built_in">ESP</span>+<span class="number">8</span>]<span class="comment">; data</span></span><br><span class="line">        <span class="keyword">OUT</span><span class="built_in">DX</span>,<span class="built_in">EAX</span></span><br><span class="line">        <span class="keyword">RET</span></span><br></pre></td></tr></table></figure><p>我們要設定調色板，就是找出對應 device 設定調色板的指令，然後照著做～</p><h3 id="CLI-與-STI"><a href="#CLI-與-STI" class="headerlink" title="CLI 與 STI"></a>CLI 與 STI</h3><p><code>CLI</code> 是將 interrupt flag clear 為 0 的指令， <code>STI</code> 則是將 interrupt flag set 為 1 的指令。</p><p>interrupt flag 為 0 時，CPU 遇到 interrupt 會忽略它、不處理，flag 為 1 時 CPU 就會處理 interrupt。</p><h3 id="EFLAGS-register"><a href="#EFLAGS-register" class="headerlink" title="EFLAGS register"></a>EFLAGS register</h3><p><code>EFLAGS</code> 是由 <code>FLAGS</code> 16 bit 的 register 擴展而來的 32 bit register。</p><p><code>FLAGS</code> 儲存 carry flag（進位 flag）與 interrupt flag 等 flag，不同 bit 代表不同 flag（有 1 個 bit 表示一個 flag 也有 2 個 bit），如下所示：</p><table><thead><tr><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td>NT</td><td>IOPL</td><td>IOPL</td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><p><code>IOPL</code> 是第 12 跟 13 bit 放在一起處理。</p><p>EFLAGS 沒有 <code>MOV</code> 指令，只能使用 <code>PUSHFD</code> 跟 <code>POPFD</code> 來讀寫。</p><p><code>PUSHFD</code> 是 push flags double-word 的縮寫，以 double word 的長度（32 bit）將 flag 的值 push 進 stack，等同 <code>PUSH EFLAGS</code>。<code>POPFD</code> 是 pop flags double-word，將 double word 長度的值從 stack pop 出來到 flag，等同 <code>POP EFLAGS</code>。</p><p>如果想把 <code>EFLAGS</code> 內的資料放到 <code>EAX</code> 裡，不能用 <code>MOV</code>，而要先 <code>PUSHFD</code> 再 <code>POP EAX</code>。反過來想把 <code>EAX</code> 的資料放進 <code>EFLAGS</code> 裡則是 <code>PUSH EAX</code> 再 <code>POPFD</code>。操作 <code>EFLAGS</code> 的組語 code 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_io_load_eflags:; int io_load_eflags(void);</span><br><span class="line">        PUSHFD; PUSH EFLAGS</span><br><span class="line">        POPEAX</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">_io_store_eflags:; void io_store_eflags(int eflags);</span><br><span class="line">        MOVEAX,[ESP+4]</span><br><span class="line">        PUSHEAX</span><br><span class="line">        POPFD; POP EFLAGS</span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>設定調色盤要先執行 <code>CLI</code>，為了在設定完後恢復 interrupt flag 的值，要先把原本的值記下來。我們可以直接把整個 eflags 記下來、執行 <code>CLI</code>、設定調色盤，最後直接把整個 eflags 的值再存回去，達到恢復 interrupt flag 的效果。</p><h2 id="在螢幕上畫圖"><a href="#在螢幕上畫圖" class="headerlink" title="在螢幕上畫圖"></a>在螢幕上畫圖</h2><p>螢幕上每個像素都對應到 VRAM 中的一個 address。向 VRAM 指定值，便能指定螢幕上像素的顏色。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這天很多在介紹 C，尤其是 pointer，作者用組語的角度去看 C，很有趣。這邊只寫些簡單的筆記。&lt;/p&gt;
&lt;p&gt;組語跟 C 一起使用時，只有 &lt;code&gt;EAX&lt;/code&gt;、&lt;code&gt;ECX&lt;/code&gt;、&lt;code&gt;EDX&lt;/code&gt; 三個 register 可</summary>
      
    
    
    
    <category term="30 天自製作業系統" scheme="http://www.cjwind.idv.tw/categories/30-%E5%A4%A9%E8%87%AA%E8%A3%BD%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
    <category term="OS" scheme="http://www.cjwind.idv.tw/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Day 3 進入 32 bit 模式並導入 C 語言</title>
    <link href="http://www.cjwind.idv.tw/30dayos/day3/"/>
    <id>http://www.cjwind.idv.tw/30dayos/day3/</id>
    <published>2020-04-25T13:59:46.000Z</published>
    <updated>2020-08-09T03:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="製作真正的-IPL"><a href="#製作真正的-IPL" class="headerlink" title="製作真正的 IPL"></a>製作真正的 IPL</h2><p>IPL 是 Initial Program Loader，現在要開始做真正的 IPL──把磁碟上的東西 load 到 memory 裡！</p><p>這部分書上是一點一點的增加 assembly code，從讀一個 sector 到讀多個 cylinder 的所有 sector。</p><h3 id="floppy-disk-的-cylinder、sector"><a href="#floppy-disk-的-cylinder、sector" class="headerlink" title="floppy disk 的 cylinder、sector"></a>floppy disk 的 cylinder、sector</h3><p>floppy disk 的磁片由外而內的一個個同心圓稱為 cylinder（柱面），共有 80 個 cylinder。由圓心往外切（像切蛋糕），cylinder 切成一格格的稱為 sector，一個 cylinder 有 18 個 sector。磁片正反面都可以存放資料，因此磁頭有正反面，以 0 跟 1 表示。</p><p>一張磁片共有 <code>2 * 80 * 18</code> 個 sector，每個 sector 是 512 byte，所以一張磁片的容量是 <code>2 * 80 * 18 * 512 = 1474560 byte = 1440 KB</code>。<em>就是古早時代的 3.5 磁片…現在應該有些人都不知道那是什麼了…</em></p><p>指定某個 sector 需要指定磁頭、cylinder 編號以及 sector 編號。</p><p><img src="/images/30dayos/floppy_disk.jpg" alt="floppy disk"></p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>JC：jump if carry<ul><li>如果 carry flag 是 1 就 jump</li><li>carry flag 是個只能存一個 bit 的 register，通常用於表示計算有無進位，也會被一些 BIOS function 用來表示回傳值。</li></ul></li><li>JNC：jump if not carry<ul><li>JC 的相反囉</li></ul></li><li>JAE：jump if above or equal<ul><li>大於等於時 jump</li></ul></li><li>JBE：jump if below or equal</li><li>JB：jump if below</li><li>EQU<ul><li>相當於 C 的 <code>#define</code> ，可以用來宣告 const</li><li><code>CYLS EQU 10</code> 就是 <code>CYLS = 10</code> 的意思</li></ul></li></ul><h3 id="Segment-Register"><a href="#Segment-Register" class="headerlink" title="Segment Register"></a>Segment Register</h3><p>一個 16 bit register 的值的範圍是 0 ~ 65535，只能表示 64 KB 的 memory address。在還沒有 32 bit register 的時代用 segment register 來表示更多 memory address。</p><p>使用 segment register 時，以 <code>ES:BX</code> 表示 <code>ES * 16 + BX</code> 的 memory address，在指令裡寫成 <code>MOV AL, [ES:BX]</code>。實際上指定 memory address 時都需要指定 segment register。省略 segment register 會預設使用 <code>DS</code> register，所以寫 <code>MOV CX, [1234]</code> 實際上是 <code>MOV CS, [DS:1234]</code> 。</p><p>因為 <code>ES:BX</code> 表示 memory address <code>ES * 16 + BX</code>，如果想將 address 往前移動 512 byte，可以在 ES 加上 <code>512 / 16 = 32 = 0x20</code>。</p><h3 id="IPL-主要-read-disk-的部分"><a href="#IPL-主要-read-disk-的部分" class="headerlink" title="IPL 主要 read disk 的部分"></a>IPL 主要 read disk 的部分</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">CYLS<span class="built_in">EQU</span><span class="number">10</span><span class="comment">; 宣告常數 CYLS = 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; (中略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; read disk</span></span><br><span class="line"><span class="keyword">MOV</span><span class="built_in">AX</span>,<span class="number">0x0820</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">ES</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="number">CH</span>,<span class="number">0</span><span class="comment">; cylinder 0</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="number">DH</span>,<span class="number">0</span><span class="comment">; 磁頭 0</span></span><br><span class="line">        <span class="comment">; sector 2, 因為 floppy disk 第一個 sector 是 boot sector, 所以從第二個 sector 開始 read</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">CL</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">readloop:</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">SI</span>,<span class="number">0</span><span class="comment">; 紀錄失敗次數的 register</span></span><br><span class="line"><span class="symbol">retry:</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="number">AH</span>,<span class="number">0x02</span><span class="comment">; AH=0x02 : read floppy disk</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">AL</span>,<span class="number">1</span><span class="comment">; 1 sector</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">DL</span>,<span class="number">0x00</span><span class="comment">; A 驅動器</span></span><br><span class="line">        <span class="keyword">INT</span><span class="number">0x13</span><span class="comment">; call BIOS</span></span><br><span class="line">        <span class="keyword">JNC</span>next<span class="comment">; 沒出錯就跳到 next</span></span><br><span class="line">        <span class="keyword">ADD</span><span class="built_in">SI</span>,<span class="number">1</span><span class="comment">; SI + 1 (這段開始在做 retry)</span></span><br><span class="line">        <span class="keyword">CMP</span><span class="built_in">SI</span>,<span class="number">5</span><span class="comment">; SI 跟 5 比較</span></span><br><span class="line">        <span class="keyword">JAE</span>error<span class="comment">; SI &gt;= 5 就跳到 error</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="number">AH</span>,<span class="number">0x00</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">DL</span>,<span class="number">0x00</span><span class="comment">; A 驅動器</span></span><br><span class="line">        <span class="keyword">INT</span><span class="number">0x13</span><span class="comment">; 重置驅動器</span></span><br><span class="line">        <span class="keyword">JMP</span>retry<span class="comment">; 回到 retry 再嘗試讀一次</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">AX</span>,<span class="built_in">ES</span><span class="comment">; 將 memory address 往後移 0x200 (512)</span></span><br><span class="line">        <span class="keyword">ADD</span><span class="built_in">AX</span>,<span class="number">0x0020</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">ES</span>,<span class="built_in">AX</span><span class="comment">; 因為沒有 ADD ES,0x020 的指令所以用比較迂迴的方式做</span></span><br><span class="line">        <span class="keyword">ADD</span><span class="built_in">CL</span>,<span class="number">1</span><span class="comment">; CL + 1 (sector)</span></span><br><span class="line">        <span class="keyword">CMP</span><span class="built_in">CL</span>,<span class="number">18</span><span class="comment">; CL 跟 18 比較</span></span><br><span class="line">        <span class="keyword">JBE</span>readloop<span class="comment">; CL &lt;= 18 則跳到 readloop (這邊就是 read 到 sector 18 的 loop)</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="built_in">CL</span>,<span class="number">1</span><span class="comment">; CL = 1</span></span><br><span class="line">        <span class="keyword">ADD</span><span class="number">DH</span>,<span class="number">1</span><span class="comment">; DH + 1</span></span><br><span class="line">        <span class="keyword">CMP</span><span class="number">DH</span>,<span class="number">2</span></span><br><span class="line">        <span class="keyword">JB</span>readloop<span class="comment">; DH &lt; 2 則跳到 readloop (這邊是 read 另一個磁頭的 loop)</span></span><br><span class="line">        <span class="keyword">MOV</span><span class="number">DH</span>,<span class="number">0</span><span class="comment">; 回到磁頭 0</span></span><br><span class="line">        <span class="keyword">ADD</span><span class="number">CH</span>,<span class="number">1</span><span class="comment">; CH + 1 (cylinder + 1)</span></span><br><span class="line">        <span class="keyword">CMP</span><span class="number">CH</span>,CYLS</span><br><span class="line">        <span class="keyword">JB</span>readloop<span class="comment">; CH &lt; CYLS 則跳到 readloop (這邊是 read cylinder 的 loop, CYLS 是常數)</span></span><br></pre></td></tr></table></figure><p>到這裡，我們就有一個將 floppy disk 資料讀到 memory 的 IPL 了！</p><h2 id="最簡單的-OS"><a href="#最簡單的-OS" class="headerlink" title="最簡單的 OS"></a>最簡單的 OS</h2><p>IPL 寫好，當然要來寫 OS 啦！</p><p>在這個部分，無論是切換 video mode、從 BIOS 取得各種資料、把一些資訊保存在 memory 中等等，都是由組語寫成的 <code>haribote.nas</code> —— 我們最簡單的 OS 程式，像這樣一個什麼事也沒幹的 OS：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">fin:</span></span><br><span class="line">        HLT</span><br><span class="line">        <span class="keyword">JMP</span>fin</span><br></pre></td></tr></table></figure><h3 id="從-boot-sector-執行-OS"><a href="#從-boot-sector-執行-OS" class="headerlink" title="從 boot sector 執行 OS"></a>從 boot sector 執行 OS</h3><p>首先透過 image file 了解在 floppy disk 上檔案是怎麼被放置的（放在哪些位置）。image file 可以想成是把 disk 上的 data「原封不動」的一個個 bit 存下來而成的一個檔案。</p><p>利用 image file 我們知道在 floppy disk 的一個檔案，檔名會寫在 <code>0x002600</code> 後（這裡的 address 是 disk 上的 address），檔案內容會在 <code>0x004200</code> 後。</p><p>所以我們把 OS 內容寫到名為 <code>haribote.sys</code> 的檔案中並存到 floppy disk，它的內容會在 <code>0x004200</code> 之後，所以我們只要從 boot sector 去執行這個位置上的東西就行了！</p><p>要怎麼去執行 disk 上 <code>0x004200</code> 後的程式呢？現在的程式是從 boot sector 開始，把 floppy disk 上的東西 load 到 memory address <code>0x8000</code> ，所以 disk 上 <code>0x4200</code> 的內容會位於 memory address <code>0x8000 + 0x4200 = 0xc200</code> 。</p><p>所以我們在 OS 程式加上 <code>ORG 0xc200</code> ，並且在 IPL 的最後加上 <code>JMP 0xc200</code> ，讓 IPL 完成工作後跳到 OS 程式所在位置開始執行！</p><h3 id="切換顯示模式（video-mode）"><a href="#切換顯示模式（video-mode）" class="headerlink" title="切換顯示模式（video mode）"></a>切換顯示模式（video mode）</h3><p>切換 video mode 的 BIOS 可以參考 <a href="http://oswiki.osask.jp/?(AT)BIOS">BIOS 網頁</a>知道要用哪些 register（雖然是日文的）。</p><p>VRAM 是 video RAM，用來顯示畫面的 memory。它的每個 address 都對應畫面上的像素，在這塊 memory 裡填值就能在畫面上畫東西～VRAM 在 memory 中有好幾塊，分別給不同 video mode 使用。</p><h3 id="進入-32-bit-mode-前的準備"><a href="#進入-32-bit-mode-前的準備" class="headerlink" title="進入 32 bit mode 前的準備"></a>進入 32 bit mode 前的準備</h3><p>32 bit mode 是 CPU 的 mode。不同 mode 有不同 instruction，所以 16 bit 跟 32 bit 的程式是不相容的。register 使用上的方便程度也不同（例如在 16 bit mode 可以方便使用 register AX，但 EAX 不好用）。另外 CPU 的保護功能（識別出可疑的 machine code 並屏蔽它）要在 32 bit mode 才能用。</p><p>不過 32 bit mode 不能使用 BIOS 功能，因為 BIOS 是用 16 bit mode 的 instruction 寫的。如果有什麼是想用 BIOS 做，要一開始先做。</p><p><em>後來出了想取代 BIOS 的 UEFI，又是另一回事了…</em></p><h2 id="導入-C-語言"><a href="#導入-C-語言" class="headerlink" title="導入 C 語言"></a>導入 C 語言</h2><p>終於開始要用 C 語言啦～在這之前得在 <code>haribote.nas</code> 加入一些組語 code，好讓我們能 call C 程式，不過作者在這裡還不想解釋那段，所以也先略過。</p><p>現在 OS 開始有組語跟 C 語言的部分，先將組語部分的 <code>haribote.nas</code> rename 成 <code>asmhead.has</code>。再加入一個很簡單的 C 程式叫 <code>bootpack.c</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程式是從這個 function 開始的，function name 不能更改，應該跟處理 C 語言的組語有關</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HariMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fin:</span><br><span class="line">    <span class="keyword">goto</span> fin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何將它變成可以在我們自製 OS 上執行的 machine code？</p><ol><li>使用 <code>cc1.exe</code> 從 <code>bootpack.c</code> 產生 <code>bootpack.gas</code><br> <code>cc1.exe</code> 是作者用 gcc 改造而來的 C compiler。gcc 是以 gas 組語為基礎，它 output 的是 gas 的 source code。<a href="https://en.wikipedia.org/wiki/GNU_Assembler">gas</a> 是 GNU 的 assembler。</li><li>用 <code>gas2nask.exe</code> 將 <code>bootpack.gas</code> 轉成 <code>bootpack.nas</code><br> 作者使用 nask 當 assembler，所以得把 gas 組語轉成 nask 組語。</li><li>用 <code>nask.exe</code> 將 <code>bootpack.nas</code> 組譯為 <code>bootpack.obj</code></li><li>用 <code>obi2bim.exe</code> 從 <code>bootpack.obj</code> 產生 <code>bootpack.bim</code><ul><li><code>obi2bim.exe</code> 是 linker，這邊是將 object file <code>bootpack.obj</code> link 成完整的 machine code。</li><li>雖然現在只有一個 object file，不是多個 object file 要 link 在一起。但即使只有一個 object file 也要幫它加些資訊才能成為完整可執行的 machine code，所以需要 link。</li><li><code>bim</code> 是作者設計的一種格式，是種 binary image file。</li></ul></li><li>最後用 <code>bim2hrb.exe</code> 從 <code>bootpack.bim</code> 產生 <code>bootpack.hrb</code><br> 這是將 <code>bootpack.bim</code> 依照我們自製 OS 的需要做點加工，成為最後的 <code>bootpack.hrb</code></li></ol><p>到這裡終於把 C 語言程式編譯成可以在自製 OS 上執行的 machine code，最後用 <code>copy</code> 指令將 <code>asmhead.nas</code> 組譯出來的 <code>asmhead.bin</code> 跟 <code>bootpack.hrb</code> 結合起來，成為最終的 <code>haribote.sys</code> 。（原本 <code>haribote.sys</code> 是直接由 <code>haribote.nas</code> 組譯而來，現在有了 C 語言的部分，要把兩個部分結合起來才是完整的 <code>haribote.sys</code> ）</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOOLPATH = ../z_tools/</span><br><span class="line">INCPATH  = ../z_tools/haribote/</span><br><span class="line"></span><br><span class="line">MAKE     = <span class="variable">$(TOOLPATH)</span>make.exe -r</span><br><span class="line">NASK     = <span class="variable">$(TOOLPATH)</span>nask.exe</span><br><span class="line">CC1      = <span class="variable">$(TOOLPATH)</span>cc1.exe -I<span class="variable">$(INCPATH)</span> -Os -Wall -quiet</span><br><span class="line">GAS2NASK = <span class="variable">$(TOOLPATH)</span>gas2nask.exe -a</span><br><span class="line">OBJ2BIM  = <span class="variable">$(TOOLPATH)</span>obj2bim.exe</span><br><span class="line">BIM2HRB  = <span class="variable">$(TOOLPATH)</span>bim2hrb.exe</span><br><span class="line">RULEFILE = <span class="variable">$(TOOLPATH)</span>haribote/haribote.rul</span><br><span class="line">EDIMG    = <span class="variable">$(TOOLPATH)</span>edimg.exe</span><br><span class="line">IMGTOL   = <span class="variable">$(TOOLPATH)</span>imgtol.com</span><br><span class="line">COPY     = copy</span><br><span class="line">DEL      = del</span><br><span class="line"></span><br><span class="line">default :</span><br><span class="line">    <span class="variable">$(MAKE)</span> img</span><br><span class="line"></span><br><span class="line">; 組譯 IPL</span><br><span class="line">ipl10.bin : ipl10.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> ipl10.nas ipl10.bin ipl10.lst</span><br><span class="line"></span><br><span class="line">; 組譯 OS 前面的組語部分</span><br><span class="line">asmhead.bin : asmhead.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> asmhead.nas asmhead.bin asmhead.lst</span><br><span class="line"></span><br><span class="line">; 使用 cc1 compile bootpack.c 得到 gas 組語</span><br><span class="line">bootpack.gas : bootpack.c Makefile</span><br><span class="line">    <span class="variable">$(CC1)</span> -o bootpack.gas bootpack.c</span><br><span class="line"></span><br><span class="line">; 將 gas 組語轉成 nask 組語</span><br><span class="line">bootpack.nas : bootpack.gas Makefile</span><br><span class="line">    <span class="variable">$(GAS2NASK)</span> bootpack.gas bootpack.nas</span><br><span class="line"></span><br><span class="line">; nask 組譯</span><br><span class="line">bootpack.obj : bootpack.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> bootpack.nas bootpack.obj bootpack.lst</span><br><span class="line"></span><br><span class="line">; linking</span><br><span class="line">bootpack.bim : bootpack.obj Makefile</span><br><span class="line">    <span class="variable">$(OBJ2BIM)</span> @<span class="variable">$(RULEFILE)</span> out:bootpack.bim stack:3136k map:bootpack.map \</span><br><span class="line">        bootpack.obj</span><br><span class="line"><span class="comment"># 3MB+64KB=3136KB</span></span><br><span class="line"></span><br><span class="line">; 幫 bootpack.bim 做點加工好能在我們的 OS 上執行</span><br><span class="line">bootpack.hrb : bootpack.bim Makefile</span><br><span class="line">    <span class="variable">$(BIM2HRB)</span> bootpack.bim bootpack.hrb 0</span><br><span class="line"></span><br><span class="line">; 將兩個部份的 machine code 結合在一起</span><br><span class="line">haribote.sys : asmhead.bin bootpack.hrb Makefile</span><br><span class="line">    copy /B asmhead.bin+bootpack.hrb haribote.sys</span><br><span class="line"></span><br><span class="line">; 將 IPL 跟 OS 的 machine code 做成 floopy disk 的 image file</span><br><span class="line">haribote.img : ipl10.bin haribote.sys Makefile</span><br><span class="line">    <span class="variable">$(EDIMG)</span>   imgin:../z_tools/fdimg0at.tek \</span><br><span class="line">        wbinimg src:ipl10.bin len:512 from:0 to:0 \</span><br><span class="line">        copy from:haribote.sys to:@: \</span><br><span class="line">        imgout:haribote.img</span><br><span class="line"></span><br><span class="line">img :</span><br><span class="line">    <span class="variable">$(MAKE)</span> haribote.img</span><br><span class="line"></span><br><span class="line">run :</span><br><span class="line">    <span class="variable">$(MAKE)</span> img</span><br><span class="line">    <span class="variable">$(COPY)</span> haribote.img ..\z_tools\qemu\fdimage0.bin</span><br><span class="line">    <span class="variable">$(MAKE)</span> -C ../z_tools/qemu</span><br><span class="line"></span><br><span class="line">install :</span><br><span class="line">    <span class="variable">$(MAKE)</span> img</span><br><span class="line">    <span class="variable">$(IMGTOL)</span> w a: haribote.img</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.bin</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.lst</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.gas</span><br><span class="line">    -<span class="variable">$(DEL)</span> *.obj</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.nas</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.map</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.bim</span><br><span class="line">    -<span class="variable">$(DEL)</span> bootpack.hrb</span><br><span class="line">    -<span class="variable">$(DEL)</span> haribote.sys</span><br><span class="line"></span><br><span class="line">src_only :</span><br><span class="line">    <span class="variable">$(MAKE)</span> clean</span><br><span class="line">    -<span class="variable">$(DEL)</span> haribote.img</span><br></pre></td></tr></table></figure><h2 id="在-C-語言程式-call-組語程式"><a href="#在-C-語言程式-call-組語程式" class="headerlink" title="在 C 語言程式 call 組語程式"></a>在 C 語言程式 call 組語程式</h2><p>如果想在 C 語言寫的程式 call 組語的程式該怎麼做呢？寫了個組語程式 <code>naskfunc.nas</code> 如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">FORMAT</span> &quot;WCOFF&quot;]; 製作 <span class="keyword">object</span> file 的模式</span><br><span class="line">[BITS <span class="number">32</span>]; 製作 <span class="number">32</span> <span class="type">bit</span> mode 用的 machine code</span><br><span class="line"></span><br><span class="line">; 製作 <span class="keyword">object</span> file 的資訊</span><br><span class="line"></span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]; source code file <span class="type">name</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">GLOBAL</span>_io_hlt; 程式中包含的 <span class="keyword">function</span> <span class="type">name</span></span><br><span class="line"></span><br><span class="line">; 以下是實際 <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">[SECTION .text]</span><br><span class="line"></span><br><span class="line">_io_hlt:; <span class="type">void</span> io_hlt(<span class="type">void</span>);</span><br><span class="line">    HLT</span><br><span class="line">    RET; 相當於 C 語言的 <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>這段組語包含一個 <code>_io_hlt</code> function。</p><p>在 nask object file 模式下，要設定 file name 資訊並且寫清楚程式的 function name。function name 要在前面加上 <code>_</code> ，不然不能跟 C 語言 function link。需要 link 的 function name 都要用 <code>GLOBAL</code> 指令宣告。</p><p>來看看在 C 語言裡要怎麼使用 <code>_io_hlt</code> function：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告訴 C compiler，這個 function 在別的 file 裡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_hlt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HariMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fin:</span><br><span class="line">    io_hlt();</span><br><span class="line">    <span class="keyword">goto</span> fin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊的 Makefile 跟前面的差異只有增加了 <code>naskfunc.obj</code> 的 target 跟修改 <code>bootpack.bim</code> target 的 link 內容：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">naskfunc.obj : naskfunc.nas Makefile</span><br><span class="line">    <span class="variable">$(NASK)</span> naskfunc.nas naskfunc.obj naskfunc.lst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多 link naskfunc.obj</span></span><br><span class="line">bootpack.bim : bootpack.obj naskfunc.obj Makefile</span><br><span class="line">    <span class="variable">$(OBJ2BIM)</span> @<span class="variable">$(RULEFILE)</span> out:bootpack.bim stack:3136k map:bootpack.map \</span><br><span class="line">        bootpack.obj naskfunc.obj</span><br></pre></td></tr></table></figure><p>到這天結束，我們已經有以下 source code：</p><ul><li><code>ipl10.nas</code>：IPL 程式</li><li><code>asmhead.nas</code>：OS 的組語部份</li><li><code>bootpack.c</code>：OS 的 C 語言部份</li><li><code>naskfunc.nas</code>：給 C 語言部份使用的組語 function</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;製作真正的-IPL&quot;&gt;&lt;a href=&quot;#製作真正的-IPL&quot; class=&quot;headerlink&quot; title=&quot;製作真正的 IPL&quot;&gt;&lt;/a&gt;製作真正的 IPL&lt;/h2&gt;&lt;p&gt;IPL 是 Initial Program Loader，現在要開始做真正的 IPL</summary>
      
    
    
    
    <category term="30 天自製作業系統" scheme="http://www.cjwind.idv.tw/categories/30-%E5%A4%A9%E8%87%AA%E8%A3%BD%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
    
    
    <category term="OS" scheme="http://www.cjwind.idv.tw/tags/OS/"/>
    
  </entry>
  
</feed>
